* Exercises Section 11.1
** Exercise 11.1
   #+BEGIN_QUOTE
   Describe the differences between a ~map~ and a ~vector~.
   #+END_QUOTE

   Associative (~map~) and sequential (~vector~) containers differ from one
   another in a fundamental way: Elements in an associative container are stored
   and retrieved by a key. In contrast, elements in a sequential container are
   stored and accessed sequentially by their position in the container.

   Although the associative containers share much of the behavior of the
   sequential containers, they differ from the sequential containers in ways
   that reflect the use of keys.
 
** Exercise 11.2
   #+BEGIN_QUOTE
   Give an example of when each of ~list~, ~vector~, ~deque~, ~map~, and ~set~
   might be most useful.
   #+END_QUOTE
   
   + ~list~ : When a doubly-linked list is required.
   + ~vector~ : When a dynamic array is required.
   + ~deque~ : When we need "fast access" to insert/deletes at both ends of the
     line.
   + ~map~ : A dictionary would be a good use for a map: The word would be the
     key, and its definition would be the value.
   + ~set~ : We might use a set to hold words that we want to ignore during some
     kind of text processing.

** Exercise 11.3
   #+BEGIN_QUOTE
   Write your own version of the word-counting program.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

#include <cstddef>
using std::size_t;

#include <string>
using std::string;

#include <map>
using std::map;

int main()
{
  // count the number of times each word occurs in the input
  map<string, size_t> word_count; // empty map from string to size_t
  string word;
  while (cin >> word)
    ++word_count[word];		// fetch and increment the counter for word
  for (const auto &w : word_count) // for each element in the map
    // print the results
    cout << w.first << " occurs " << w.second
	 << ((w.second > 1) ? " times" : " time") << endl;

  return 0;
}   
   #+END_SRC

** Exercise 11.4
   #+BEGIN_QUOTE
   Extend your program to ignore case and punctuation. For example, “example.”
   “example,” and “Example” should all increment the same counter.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

#include <cstddef>
using std::size_t;

#include <cctype>
using std::tolower; using std::ispunct;

#include <string>
using std::string;

#include <map>
using std::map;

#include <algorithm>
using std::for_each; using std::remove_if;

int main()
{
  // count the number of times each word occurs in the input
  map<string, size_t> word_count; // empty map from string to size_t
  string word;
  while (cin >> word) {
    for_each(word.begin(), word.end(), [](char &c) { tolower(c); });
    auto iter = remove_if(word.begin(), word.end(),
			  [](char c) 
			  { return ispunct(static_cast<unsigned char>(c)); });
    word.erase(iter, word.end());
    ++word_count[word];		// fetch and increment the counter for word
  }

  for (const auto &w : word_count) // for each element in the map
    // print the results
    cout << w.first << " occurs " << w.second
	 << ((w.second > 1) ? " times" : " time") << endl;

  return 0;
}   
   #+END_SRC

* Exercises Section 11.2.1
** Exercise 11.5
   #+BEGIN_QUOTE
   Explain the difference between a ~map~ and a ~set~. When might you use one or
   the other?
   #+END_QUOTE

   Both ~std::set~ and ~std::map~ are associative containers. The difference is
   that ~std::sets~ contain only the key, while in ~std::map~ there is an
   associated value. Choosing one over the other depends mainly on what the task
   at hand is. If you want to build a dictionary of all the words that appear in
   a text, you could use a ~std::set<std::string>~, but if you also want to
   count how many times each word appeared (i.e. associate a value to the key)
   then you would need an ~std::map<std::string,int>~. If you don't need to
   associate that count, it does not make sense to have the ~int~ that is
   unnecessary.

** Exercise 11.6
   #+BEGIN_QUOTE
   Explain the difference between a ~set~ and a ~list~. When might you use one
   or the other?
   #+END_QUOTE

   ~list~:
   + Searching (linear time).
   + Inserting, deleting, moving (takes constant time).
   + Elements may be ordered.
   + Elements may be sorted.
   + Elements may be duplicate.

   ~set~:
   + Searching (logarithmic in size).
   + Insert and delete (logarithimic in general).
   + Elements are un-ordered.
   + Elements are always sorted from lower to higher.
   + Elements are unique.

** Exercise 11.7
   #+BEGIN_QUOTE
   Define a ~map~ for which the key is the family’s last name and the value is a
   ~vector~ of the children’s names. Write code to add new families and to add
   new children to an existing family.
   #+END_QUOTE

   Note: each time the program will read a line which represents a single
   person with his/her last_name and first_name.
 
   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

#include<sstream>
using std::istringstream;

#include <cstddef>
using std::size_t;

#include <vector>
using std::vector;

#include <string>
using std::string;

#include <map>
using std::map;

int main()
{
  map<string, vector<string>> families;
  string line;
  while (getline(cin, line)) {
    istringstream str(line);
    string last_name, first_name;
    str >> last_name >> first_name;
    families[last_name].push_back(first_name);
  }

  for (const auto &m : families) {
    cout << "Family: " << m.first << endl
	 << "Children: ";
    for (const auto &v : m.second) {
      cout << v << " ";
    }
    cout << endl;
  }

  return 0;
}   
   #+END_SRC

** Exercise 11.8
   #+BEGIN_QUOTE
   Write a program that stores the excluded words in a ~vector~ instead of in a
   ~set~. What are the advantages to using a ~set~?
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <map>
using std::map;

#include <algorithm>
using std::find;

int main()
{
    vector<string> exclude = {"the", "but", "and", "or", "an", "a",
			      "The", "But", "And", "Or", "An", "A"};
    map<string, size_t> word_count; // empty map from string to size_t
    string word;
    while (cin >> word) {
      if (find(exclude.begin(), exclude.end(), word) == exclude.end()) {
	++word_count[word];
      } else {
	cout << "excluded: " << word << endl;
      }
    }
    for (const auto &w : word_count) // for each element in the map
      // print the results
      cout << w.first << " occurs " << w.second
	   << ((w.second > 1) ? " times" : " time") << endl;

    return 0;
}   
   #+END_SRC

   A ~set~ is ordered. It is guaranteed to remain in a specific ordering,
   according to a functor that you provide. No matter what elements you add or
   remove (unless you add a duplicate, which is not allowed in a ~set~), it will
   always be ordered.

   A ~vector~ has exactly and only the ordering you explicitly give it. Items in
   a ~vector~ are where you put them. If you put them in out of order, then
   they're out of order; you now need to sort the container to put them back in
   order.

   Admittedly, ~set~ has relatively limited use. With proper discipline, one
   could insert items into a ~vector~ and keep it ordered. However, if you are
   constantly inserting and removing items from the container, vector will run
   into many issues. It will be doing a lot of copying/moving of elements and so
   forth, since it is effectively just an array.

   The time it takes to insert an item into a ~vector~ is proportional to the
   number of items already in the ~vector~. The time it takes to insert an item
   into a ~set~ is proportional to the log2 of the number of items. If the
   number of items is large, that's a huge difference. log2(100,000) is ~16;
   that's a major speed improvement. The same goes for removal.

   However, if you do all of your insertions at once, at initialization time,
   then there's no problem. You can insert everything into the ~vector~, sort it
   (paying that price once), and then use standard algorithms for sorted vectors
   to find elements and iterate over the sorted list. And while iteration over
   the elements of a ~set~ isn't exactly slow, iterating over a ~vector~ is
   faster.

   So there are cases where a sorted ~vector~ beats a ~set~. That being said,
   you really shouldn't bother with the expense of this kind of optimization
   unless you know that it is necessary. So use a ~set~ unless you have
   experience with the kind of system you're writing (and thus know that you
   need that performance) or have profiling data in hand that tells you that you
   need a ~vector~ and not a ~set~.
