#+STARTUP: content

* Exercises Section 6.1
** Exercise 6.1
   #+BEGIN_QUOTE
   What is the difference between a parameter and an argument?
   #+END_QUOTE

   Arguments are the initializers for a function’s parameters.

** Exercise 6.2
   #+BEGIN_QUOTE
   Indicate which of the following functions are in error and why. Suggest how
   you might correct the problems.
   + (a) ~int f() { string s; // ...
     return s;}~
   + (b) ~f2(int i) { /* ... */ }~
   + (c) ~int calc(int v1, int v1) /* ... */ }~
   + (d) ~double square(double x) return x * x;~
   #+END_QUOTE

   + (a) function return type should be ~string~
     #+BEGIN_SRC C++
int f() {
  string s;
  // ...
  return s;
}     
     #+END_SRC

   + (b) The function return type should be ~void~, which means that the function
     does not return a value.
     #+BEGIN_SRC C++
void f2(int i) {
  /* ... */
}     
     #+END_SRC

   + (c) The left curly brace is missing.
     #+BEGIN_SRC C++
int calc(int v1, int v1) {
  /* ... */ 
}     
     #+END_SRC

   + (d) The curly braces are needed for function body.
     #+BEGIN_SRC C++
double square(double x) {
  return x * x;
}     
     #+END_SRC

** Exercise 6.3
   #+BEGIN_QUOTE
   Write and test your own version of ~fact~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

// factorial of val is val*(val-1)*(val-2)...*2*1
int fact(int val)
{
  int ret = 1;			// local variable to hold the results as we
				// calculate it
  while (val > 1)
    ret *= val--;		// assign ret * val to ret and decrement val
  return ret;			// return the result;
}

int main()
{
  int j = fact(5);		// j equals 120, i.e., the result of fact(5)
  cout << "5! is " << j << endl;

  return 0;
}   
   #+END_SRC

** Exercise 6.4
   #+BEGIN_QUOTE
   Write a function that interacts with the user, asking for a number and
   generating the factorial of that number. Call this function from ~main~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

// factorial of val is val*(val-1)*(val-2)...*2*1
int fact(int val)
{
  int ret = 1;			// local variable to hold the results as we
				// calculate it
  while (val > 1)
    ret *= val--;		// assign ret * val to ret and decrement val
  return ret;			// return the result;
}

int main()
{
  cout << "please enter an integer: ";
  int i;
  cin >> i;
  int j = fact(i);
  cout << i << "! is " << j << endl;

  return 0;
}   
   #+END_SRC

** Exercise 6.5
   #+BEGIN_QUOTE
   Write a function to return the absolute value of its argument.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

int abs(int val) {
  return val >= 0 ? val : -val;
}

int main()
{
  cout << "please enter an integer: ";
  int i;
  cin >> i;
  int j = abs(i);
  cout << "The absolute value of " << i
       << " is " << j << endl;

  return 0;
}   
   #+END_SRC

* Exercises Section 6.1.1
** Exercise 6.6 
   #+BEGIN_QUOTE
   Explain the differences between a parameter, a local variable, and a local
   ~static~ variable. Give an example of a function in which each might be
   useful.
   #+END_QUOTE
   
   Parameters and variables defined inside a function body are referred to as
   local variables. They are “local” to that function and hide declarations of
   the same name made in an outer scope.
    
   It can be useful to have a local variable whose lifetime continues across
   calls to the function. We obtain such objects by defining a local variable as
   static. Each local static object is initialized before the first time
   execution passes through the object’s definition. Local statics are not
   destroyed when a function ends; they are destroyed when the program
   terminates.

   #+BEGIN_SRC C++
size_t count_calls(bool trace)  // trace is a parameter
{
  static size_t ctr = 0;  // ctr is a local static variable
  size_t result = ++ctr;  // result is a local variable
  return result;
}   
   #+END_SRC

** Exercise 6.7
   #+BEGIN_QUOTE
   Write a function that returns 0 when it is first called and then generates
   numbers in sequence each time it is called again.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <cstddef>
using std::size_t;

size_t count()
{
  static size_t ctr = 0;	// value will persist across calls
  return ctr++;
}

int main()
{
  for (size_t i = 0; i != 10; ++i)
    cout << count() << endl;
  
  return 0;
}   
   #+END_SRC

* Exercises Section 6.1.2
** Exercise 6.8
   #+BEGIN_QUOTE
   Write a header file named ~Chapter6.h~ that contains declarations for the
   functions you wrote for the exercises in § 6.1 (p. 205).
   #+END_QUOTE
   
   Chapter6.h
   #+BEGIN_SRC C++
int fact(int val);   
   #+END_SRC

* Exercises Section 6.1.3
** Exercise 6.9
   #+BEGIN_QUOTE
   Write your own versions of the ~fact.cc~ and ~factMain.cc~ files. These files
   should include your ~Chapter6.h~ from the exercises in the previous
   section. Use these files to understand how your compiler supports separate
   compilation.
   #+END_QUOTE

   fact.cc
   #+BEGIN_SRC C++
#include "Chapter6.h"

// factorial of val is val*(val-1)*(val-2)...*2*1
int fact(int val)
{
  int ret = 1;			// local variable to hold the results as we
				// calculate it
  while (val > 1)
    ret *= val--;		// assign ret * val to ret and decrement val
  return ret;			// return the result;
}   
   #+END_SRC

   factMain.cc
   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include "Chapter6.h"

int main()
{
  int j = fact(5);		// j equals 120, i.e., the result of fact(5)
  cout << "5! is " << j << endl;

  return 0;
}   
   #+END_SRC

* Exercises Section 6.2.1
** Exercise 6.10
   #+BEGIN_QUOTE
   Using pointers, write a function to swap the values of two ~int~s. Test the
   function by calling it and printing the swapped values.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

void swap(int *ip1, int *ip2) {
  int temp = *ip1;
  *ip1 = *ip2;
  *ip2 = temp;
}

int main()
{
  cout << "please enter two integers: ";

  int ival1, ival2;
  cin >> ival1 >> ival2;

  swap(&ival1, &ival2);
  
  cout << ival1 << " "
       << ival2 << endl;

  return 0;
}   
   #+END_SRC
