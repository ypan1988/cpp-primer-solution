* Exercises Section 6.1
** Exercise 6.1
   #+BEGIN_QUOTE
   What is the difference between a parameter and an argument?
   #+END_QUOTE

   Arguments are the initializers for a function’s parameters.

** Exercise 6.2
   #+BEGIN_QUOTE
   Indicate which of the following functions are in error and why. Suggest how
   you might correct the problems.
   + (a) ~int f() { string s; // ...
     return s;}~
   + (b) ~f2(int i) { /* ... */ }~
   + (c) ~int calc(int v1, int v1) /* ... */ }~
   + (d) ~double square(double x) return x * x;~
   #+END_QUOTE

   + (a) function return type should be ~string~
     #+BEGIN_SRC C++
int f() {
  string s;
  // ...
  return s;
}     
     #+END_SRC

   + (b) The function return type should be ~void~, which means that the function
     does not return a value.
     #+BEGIN_SRC C++
void f2(int i) {
  /* ... */
}     
     #+END_SRC

   + (c) The left curly brace is missing.
     #+BEGIN_SRC C++
int calc(int v1, int v1) {
  /* ... */ 
}     
     #+END_SRC

   + (d) The curly braces are needed for function body.
     #+BEGIN_SRC C++
double square(double x) {
  return x * x;
}     
     #+END_SRC

** Exercise 6.3
   #+BEGIN_QUOTE
   Write and test your own version of ~fact~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

// factorial of val is val*(val-1)*(val-2)...*2*1
int fact(int val)
{
  int ret = 1;			// local variable to hold the results as we
				// calculate it
  while (val > 1)
    ret *= val--;		// assign ret * val to ret and decrement val
  return ret;			// return the result;
}

int main()
{
  int j = fact(5);		// j equals 120, i.e., the result of fact(5)
  cout << "5! is " << j << endl;

  return 0;
}   
   #+END_SRC

** Exercise 6.4
   #+BEGIN_QUOTE
   Write a function that interacts with the user, asking for a number and
   generating the factorial of that number. Call this function from ~main~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

// factorial of val is val*(val-1)*(val-2)...*2*1
int fact(int val)
{
  int ret = 1;			// local variable to hold the results as we
				// calculate it
  while (val > 1)
    ret *= val--;		// assign ret * val to ret and decrement val
  return ret;			// return the result;
}

int main()
{
  cout << "please enter an integer: ";
  int i;
  cin >> i;
  int j = fact(i);
  cout << i << "! is " << j << endl;

  return 0;
}   
   #+END_SRC

** Exercise 6.5
   #+BEGIN_QUOTE
   Write a function to return the absolute value of its argument.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

int abs(int val) {
  return val >= 0 ? val : -val;
}

int main()
{
  cout << "please enter an integer: ";
  int i;
  cin >> i;
  int j = abs(i);
  cout << "The absolute value of " << i
       << " is " << j << endl;

  return 0;
}   
   #+END_SRC

* Exercises Section 6.1.1
** Exercise 6.6 
   #+BEGIN_QUOTE
   Explain the differences between a parameter, a local variable, and a local
   ~static~ variable. Give an example of a function in which each might be
   useful.
   #+END_QUOTE
   
   Parameters and variables defined inside a function body are referred to as
   local variables. They are “local” to that function and hide declarations of
   the same name made in an outer scope.
    
   It can be useful to have a local variable whose lifetime continues across
   calls to the function. We obtain such objects by defining a local variable as
   static. Each local static object is initialized before the first time
   execution passes through the object’s definition. Local statics are not
   destroyed when a function ends; they are destroyed when the program
   terminates.

   #+BEGIN_SRC C++
size_t count_calls(bool trace)  // trace is a parameter
{
  static size_t ctr = 0;  // ctr is a local static variable
  size_t result = ++ctr;  // result is a local variable
  return result;
}   
   #+END_SRC

** Exercise 6.7
   #+BEGIN_QUOTE
   Write a function that returns 0 when it is first called and then generates
   numbers in sequence each time it is called again.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <cstddef>
using std::size_t;

size_t count()
{
  static size_t ctr = 0;	// value will persist across calls
  return ctr++;
}

int main()
{
  for (size_t i = 0; i != 10; ++i)
    cout << count() << endl;
  
  return 0;
}   
   #+END_SRC
