* Exercises Section 10.1
** Exercise 10.1
   #+BEGIN_QUOTE
   The ~algorithm~ header defines a function named ~count~ that, like ~find~,
   takes a pair of iterators and a value. ~count~ returns a count of how often
   that value appears. Read a sequence of ~int~ s into a ~vector~ and print the
   ~count~ of how many elements have a given value.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::count;

int main()
{
  vector<int> ivec = {1, 1, 1, 1, 2, 2, 2, 3, 3, 4};

  int ival = 1;
  cout << count(ivec.cbegin(), ivec.cend(), ival)
       << " elements have value " << ival << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.2
   #+BEGIN_QUOTE
   Repeat the previous program, but read values into a list of ~string~ s.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::count;

int main()
{
  vector<string> svec = {"aaa", "aaa", "aaa", "aaa", "bbb", "bbb", "bbb", "ccc",
                         "ccc", "ddd"};

  string s = "aaa";
  cout << count(svec.cbegin(), svec.cend(), s)
       << " strings have value " << s << endl;

  return 0;
}
   #+END_SRC

* Exercises Section 10.2.1
** Exercise 10.3
   #+BEGIN_QUOTE
   Use ~accumulate~ to sum the elements in a ~vector<int>~ .
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::accumulate;

int main()
{
  vector<int> ivec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  int sum = accumulate(ivec.cbegin(), ivec.cend(), 0);
  cout << "sum: "<< sum << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.4
   #+BEGIN_QUOTE
   Assuming ~v~ is a ~vector<double>~, what, if anything, is wrong with calling
   ~accumulate(v.cbegin(), v.cend(), 0)~?
   #+END_QUOTE

   The third argument of ~accumulate~ should be replace with 0.0

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::accumulate;

int main()
{
  vector<double> ivec = {1.1, 2.2, 3.3};

  double sum = accumulate(ivec.cbegin(), ivec.cend(), 0.0);
  cout << "sum: "<< sum << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.5
   #+BEGIN_QUOTE
   In the call to equal on rosters, what would happen if both rosters held
   C-style strings, rather than library strings?
   #+END_QUOTE

   For such case, ~std::equal~ is going to compare the address values rather
   than the ~string~ values. So the result is not the same as ~std::string~. Try
   to avoid coding this way.

* Exercises Section 10.2.2
** Exercise 10.6
   #+BEGIN_QUOTE
   Using ~fill_n~, write a program to set a sequence of ~int~ values to 0.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::fill_n;

int main()
{
  vector<int> ivec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  fill_n(ivec.begin(), ivec.size(), 0);

  for (auto ival : ivec)
    cout << ival << " ";

  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.7
   #+BEGIN_QUOTE
   Determine if there are any errors in the following programs and, if so,
   correct the error(s):
   + (a)
     #+BEGIN_SRC C++
vector<int> vec; list<int> lst; int i;
while (cin >> i)
  lst.push_back(i);
copy(lst.cbegin(), lst.cend(), vec.begin());
     #+END_SRC
   + (b)
     #+BEGIN_SRC C++
vector<int> vec;
vec.reserve(10); // reserve is covered in § 9.4 (p. 356)
fill_n(vec.begin(), 10, 0);
     #+END_SRC
   #+END_QUOTE

   + (a) incorrect. ~copy~ assumes that the second sequence is at least as large
     as the first.

     fix: ~copy(lst.cbegin(), lst.cend(), back_inserter(vec.begin()));~

   + (b) incorrect. ~fill_n~ assumes that it is safe to write the specified
     number of elements.

     fix: ~fill_n(back_inserter(vec), 10, 0)~

** Exercise 10.8
   #+BEGIN_QUOTE
   We said that algorithms do not change the size of the containers over which
   they operate. Why doesn’t the use of ~back_inserter~ invalidate this claim?
   #+END_QUOTE

   ~back_inserter~ takes a reference to a container and returns an insert
   iterator bound to that container. When we assign through that iterator, the
   assignment calls ~push_back~ to add an element with the given value to the
   container.

* Exercises Section 10.2.3
** Exercise 10.9
   #+BEGIN_QUOTE
   Implement your own version of ~elimDups~. Test your program by printing the
   ~vector~ after you read the input, after the call to ~unique~, and after the
   call to ~erase~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::unique;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  elimDups(svec);
  
  for (const auto &str : svec) cout << str << " ";
  cout << endl;
  
  return 0;
}   
   #+END_SRC

** Exercise 10.10
   #+BEGIN_QUOTE
   Why do you think the algorithms don’t change the size of containers?
   #+END_QUOTE

   The library algorithms operate on iterators, not containers. Therefore, an
   algorithm cannot (directly) add or remove elements.

* Exercises Section 10.3.1
** Exercise 10.11
   #+BEGIN_QUOTE
   Write a program that uses ~stable_sort~ and ~isShorter~ to sort a ~vector~
   passed to your version of ~elimDups~. Print the vector to verify that your
   program is correct.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::stable_sort;
using std::unique;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)
{
  return s1.size() < s2.size();
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  elimDups(svec);
  
  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  stable_sort(svec.begin(), svec.end(), isShorter);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}   
   #+END_SRC

** Exercise 10.12
   #+BEGIN_QUOTE
   Write a function named ~compareIsbn~ that compares the ~isbn()~ members of
   two ~Sales_data~ objects. Use that function to sort a ~vector~ that holds
   ~Sales_data~ objects.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

struct Sales_data;
std::istream& read(std::istream &is, Sales_data &item);

struct Sales_data {
  // friend declarations for nonmember Sales_data operations added
  friend Sales_data add(const Sales_data &lhs, const Sales_data &rhs);
  friend std::istream& read(std::istream &is, Sales_data &item);
  friend std::ostream& print(std::ostream &os, const Sales_data &item);

  // other members and access specifiers as before
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &is) { read(is, *this); }

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

private:
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};


// definitions for nonmember parts of the Sales_data interface
Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

bool compareIsbn(const Sales_data &obj1, const Sales_data &obj2) {
  return obj1.isbn() < obj2.isbn();
}

int main()
{
  Sales_data trans1("bbb");
  Sales_data trans2("aaa");
  Sales_data trans3("ccc");
  Sales_data trans4("bb");
  
  std::vector<Sales_data> vec = {trans1, trans2, trans3, trans4};
  std::sort(vec.begin(), vec.end(), compareIsbn);

  for (const auto &trans : vec) {
    std::cout << trans.isbn() << std::endl;
  }

  return 0;
}   
   #+END_SRC

** Exercise 10.13
   #+BEGIN_QUOTE
   The library defines an algorithm named ~partition~ that takes a predicate and
   partitions the container so that values for which the predicate is ~true~
   appear in the first part and those for which the predicate is ~false~ appear
   in the second part. The algorithm returns an iterator just past the last
   element for which the predicate returned ~true~. Write a function that takes
   a ~string~ and returns a ~bool~ indicating whether the ~string~ has five
   characters or more. Use that function to partition ~words~. Print the
   elements that have five or more characters.
   #+END_QUOTE

* Exercises Section 10.3.2
** Exercise 10.14
   #+BEGIN_QUOTE
   Write a lambda that takes two ~int~ s and returns their sum.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

int main()
{
  auto f = [](int a, int b)
    { return a + b; };

  cout << f(1, 2) << endl;

  return 0;
}   
   #+END_SRC

** Exercise 10.15
   #+BEGIN_QUOTE
   Write a lambda that captures an ~int~ from its enclosing function and takes
   an ~int~ parameter. The lambda should return the sum of the captured ~int~
   and the ~int~ parameter.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

int main()
{
  int a = 1;
  auto f = [a](int b)
    { return a + b; };

  cout << f(2) << endl;

  return 0;
}   
   #+END_SRC

** Exercise 10.16
   #+BEGIN_QUOTE
   Write your own version of the biggies function using lambdas.
   #+END_QUOTE

** Exercise 10.17
   #+BEGIN_QUOTE
   Rewrite exercise 10.12 from § 10.3.1 (p. 387) to use a lambda in the call
   to sort instead of the compareIsbn function.
   #+END_QUOTE

** Exercise 10.18
   #+BEGIN_QUOTE
   Rewrite biggies to use partition instead of find_if.  We described the
   partition algorithm in exercise 10.13 in § 10.3.1 (p. 387).
   #+END_QUOTE

** Exercise 10.19
   #+BEGIN_QUOTE
   Rewrite the previous exercise to use stable_partition, which like
   stable_sort maintains the original element order in the paritioned
   sequence.
   #+END_QUOTE
