* Exercises Section 10.1
** Exercise 10.1
   #+BEGIN_QUOTE
   The ~algorithm~ header defines a function named ~count~ that, like ~find~,
   takes a pair of iterators and a value. ~count~ returns a count of how often
   that value appears. Read a sequence of ~int~ s into a ~vector~ and print the
   ~count~ of how many elements have a given value.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::count;

int main()
{
  vector<int> ivec = {1, 1, 1, 1, 2, 2, 2, 3, 3, 4};

  int ival = 1;
  cout << count(ivec.cbegin(), ivec.cend(), ival)
       << " elements have value " << ival << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.2
   #+BEGIN_QUOTE
   Repeat the previous program, but read values into a list of ~string~ s.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::count;

int main()
{
  vector<string> svec = {"aaa", "aaa", "aaa", "aaa", "bbb", "bbb", "bbb", "ccc",
                         "ccc", "ddd"};

  string s = "aaa";
  cout << count(svec.cbegin(), svec.cend(), s)
       << " strings have value " << s << endl;

  return 0;
}
   #+END_SRC

* Exercises Section 10.2.1
** Exercise 10.3
   #+BEGIN_QUOTE
   Use ~accumulate~ to sum the elements in a ~vector<int>~ .
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::accumulate;

int main()
{
  vector<int> ivec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  int sum = accumulate(ivec.cbegin(), ivec.cend(), 0);
  cout << "sum: "<< sum << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.4
   #+BEGIN_QUOTE
   Assuming ~v~ is a ~vector<double>~, what, if anything, is wrong with calling
   ~accumulate(v.cbegin(), v.cend(), 0)~?
   #+END_QUOTE

   The third argument of ~accumulate~ should be replace with 0.0

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::accumulate;

int main()
{
  vector<double> ivec = {1.1, 2.2, 3.3};

  double sum = accumulate(ivec.cbegin(), ivec.cend(), 0.0);
  cout << "sum: "<< sum << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.5
   #+BEGIN_QUOTE
   In the call to equal on rosters, what would happen if both rosters held
   C-style strings, rather than library strings?
   #+END_QUOTE

   For such case, ~std::equal~ is going to compare the address values rather
   than the ~string~ values. So the result is not the same as ~std::string~. Try
   to avoid coding this way.

* Exercises Section 10.2.2
** Exercise 10.6
   #+BEGIN_QUOTE
   Using ~fill_n~, write a program to set a sequence of ~int~ values to 0.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::fill_n;

int main()
{
  vector<int> ivec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  fill_n(ivec.begin(), ivec.size(), 0);

  for (auto ival : ivec)
    cout << ival << " ";

  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.7
   #+BEGIN_QUOTE
   Determine if there are any errors in the following programs and, if so,
   correct the error(s):
   + (a)
     #+BEGIN_SRC C++
vector<int> vec; list<int> lst; int i;
while (cin >> i)
  lst.push_back(i);
copy(lst.cbegin(), lst.cend(), vec.begin());
     #+END_SRC
   + (b)
     #+BEGIN_SRC C++
vector<int> vec;
vec.reserve(10); // reserve is covered in § 9.4 (p. 356)
fill_n(vec.begin(), 10, 0);
     #+END_SRC
   #+END_QUOTE

   + (a) incorrect. ~copy~ assumes that the second sequence is at least as large
     as the first.

     fix: ~copy(lst.cbegin(), lst.cend(), back_inserter(vec.begin()));~

   + (b) incorrect. ~fill_n~ assumes that it is safe to write the specified
     number of elements.

     fix: ~fill_n(back_inserter(vec), 10, 0)~

** Exercise 10.8
   #+BEGIN_QUOTE
   We said that algorithms do not change the size of the containers over which
   they operate. Why doesn’t the use of ~back_inserter~ invalidate this claim?
   #+END_QUOTE

   ~back_inserter~ takes a reference to a container and returns an insert
   iterator bound to that container. When we assign through that iterator, the
   assignment calls ~push_back~ to add an element with the given value to the
   container.

* Exercises Section 10.2.3
** Exercise 10.9
   #+BEGIN_QUOTE
   Implement your own version of ~elimDups~. Test your program by printing the
   ~vector~ after you read the input, after the call to ~unique~, and after the
   call to ~erase~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::unique;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  elimDups(svec);
  
  for (const auto &str : svec) cout << str << " ";
  cout << endl;
  
  return 0;
}   
   #+END_SRC

** Exercise 10.10
   #+BEGIN_QUOTE
   Why do you think the algorithms don’t change the size of containers?
   #+END_QUOTE

   The library algorithms operate on iterators, not containers. Therefore, an
   algorithm cannot (directly) add or remove elements.
