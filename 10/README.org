* Exercises Section 10.1
** Exercise 10.1
   #+BEGIN_QUOTE
   The ~algorithm~ header defines a function named ~count~ that, like ~find~,
   takes a pair of iterators and a value. ~count~ returns a count of how often
   that value appears. Read a sequence of ~int~ s into a ~vector~ and print the
   ~count~ of how many elements have a given value.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::count;

int main()
{
  vector<int> ivec = {1, 1, 1, 1, 2, 2, 2, 3, 3, 4};

  int ival = 1;
  cout << count(ivec.cbegin(), ivec.cend(), ival)
       << " elements have value " << ival << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.2
   #+BEGIN_QUOTE
   Repeat the previous program, but read values into a list of ~string~ s.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::count;

int main()
{
  vector<string> svec = {"aaa", "aaa", "aaa", "aaa", "bbb", "bbb", "bbb", "ccc",
                         "ccc", "ddd"};

  string s = "aaa";
  cout << count(svec.cbegin(), svec.cend(), s)
       << " strings have value " << s << endl;

  return 0;
}
   #+END_SRC

* Exercises Section 10.2.1
** Exercise 10.3
   #+BEGIN_QUOTE
   Use ~accumulate~ to sum the elements in a ~vector<int>~ .
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::accumulate;

int main()
{
  vector<int> ivec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  int sum = accumulate(ivec.cbegin(), ivec.cend(), 0);
  cout << "sum: "<< sum << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.4
   #+BEGIN_QUOTE
   Assuming ~v~ is a ~vector<double>~, what, if anything, is wrong with calling
   ~accumulate(v.cbegin(), v.cend(), 0)~?
   #+END_QUOTE

   The third argument of ~accumulate~ should be replace with 0.0

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::accumulate;

int main()
{
  vector<double> ivec = {1.1, 2.2, 3.3};

  double sum = accumulate(ivec.cbegin(), ivec.cend(), 0.0);
  cout << "sum: "<< sum << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.5
   #+BEGIN_QUOTE
   In the call to equal on rosters, what would happen if both rosters held
   C-style strings, rather than library strings?
   #+END_QUOTE

   For such case, ~std::equal~ is going to compare the address values rather
   than the ~string~ values. So the result is not the same as ~std::string~. Try
   to avoid coding this way.

* Exercises Section 10.2.2
** Exercise 10.6
   #+BEGIN_QUOTE
   Using ~fill_n~, write a program to set a sequence of ~int~ values to 0.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::fill_n;

int main()
{
  vector<int> ivec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  fill_n(ivec.begin(), ivec.size(), 0);

  for (auto ival : ivec)
    cout << ival << " ";

  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.7
   #+BEGIN_QUOTE
   Determine if there are any errors in the following programs and, if so,
   correct the error(s):
   + (a)
     #+BEGIN_SRC C++
vector<int> vec; list<int> lst; int i;
while (cin >> i)
  lst.push_back(i);
copy(lst.cbegin(), lst.cend(), vec.begin());
     #+END_SRC
   + (b)
     #+BEGIN_SRC C++
vector<int> vec;
vec.reserve(10); // reserve is covered in § 9.4 (p. 356)
fill_n(vec.begin(), 10, 0);
     #+END_SRC
   #+END_QUOTE

   + (a) incorrect. ~copy~ assumes that the second sequence is at least as large
     as the first.

     fix: ~copy(lst.cbegin(), lst.cend(), back_inserter(vec.begin()));~

   + (b) incorrect. ~fill_n~ assumes that it is safe to write the specified
     number of elements.

     fix: ~fill_n(back_inserter(vec), 10, 0)~

** Exercise 10.8
   #+BEGIN_QUOTE
   We said that algorithms do not change the size of the containers over which
   they operate. Why doesn’t the use of ~back_inserter~ invalidate this claim?
   #+END_QUOTE

   ~back_inserter~ takes a reference to a container and returns an insert
   iterator bound to that container. When we assign through that iterator, the
   assignment calls ~push_back~ to add an element with the given value to the
   container.

* Exercises Section 10.2.3
** Exercise 10.9
   #+BEGIN_QUOTE
   Implement your own version of ~elimDups~. Test your program by printing the
   ~vector~ after you read the input, after the call to ~unique~, and after the
   call to ~erase~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::unique;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  elimDups(svec);
  
  for (const auto &str : svec) cout << str << " ";
  cout << endl;
  
  return 0;
}   
   #+END_SRC

** Exercise 10.10
   #+BEGIN_QUOTE
   Why do you think the algorithms don’t change the size of containers?
   #+END_QUOTE

   The library algorithms operate on iterators, not containers. Therefore, an
   algorithm cannot (directly) add or remove elements.

* Exercises Section 10.3.1
** Exercise 10.11
   #+BEGIN_QUOTE
   Write a program that uses ~stable_sort~ and ~isShorter~ to sort a ~vector~
   passed to your version of ~elimDups~. Print the vector to verify that your
   program is correct.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::stable_sort;
using std::unique;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)
{
  return s1.size() < s2.size();
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  elimDups(svec);
  
  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  stable_sort(svec.begin(), svec.end(), isShorter);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}   
   #+END_SRC

** Exercise 10.12
   #+BEGIN_QUOTE
   Write a function named ~compareIsbn~ that compares the ~isbn()~ members of
   two ~Sales_data~ objects. Use that function to sort a ~vector~ that holds
   ~Sales_data~ objects.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

struct Sales_data;
std::istream& read(std::istream &is, Sales_data &item);

struct Sales_data {
  // friend declarations for nonmember Sales_data operations added
  friend Sales_data add(const Sales_data &lhs, const Sales_data &rhs);
  friend std::istream& read(std::istream &is, Sales_data &item);
  friend std::ostream& print(std::ostream &os, const Sales_data &item);

  // other members and access specifiers as before
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &is) { read(is, *this); }

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

private:
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};


// definitions for nonmember parts of the Sales_data interface
Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

bool compareIsbn(const Sales_data &obj1, const Sales_data &obj2) {
  return obj1.isbn() < obj2.isbn();
}

int main()
{
  Sales_data trans1("bbb");
  Sales_data trans2("aaa");
  Sales_data trans3("ccc");
  Sales_data trans4("bb");
  
  std::vector<Sales_data> vec = {trans1, trans2, trans3, trans4};
  std::sort(vec.begin(), vec.end(), compareIsbn);

  for (const auto &trans : vec) {
    std::cout << trans.isbn() << std::endl;
  }

  return 0;
}   
   #+END_SRC

** Exercise 10.13
   #+BEGIN_QUOTE
   The library defines an algorithm named ~partition~ that takes a predicate and
   partitions the container so that values for which the predicate is ~true~
   appear in the first part and those for which the predicate is ~false~ appear
   in the second part. The algorithm returns an iterator just past the last
   element for which the predicate returned ~true~. Write a function that takes
   a ~string~ and returns a ~bool~ indicating whether the ~string~ has five
   characters or more. Use that function to partition ~words~. Print the
   elements that have five or more characters.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::partition;

bool isLarger5(const string &s)
{
  return s.size() >= 5;
}

int main()
{
  vector<string> svec = {"aaa", "Hello", "bbb", "world!!!", "ccc"};
  auto bound = partition(svec.begin(), svec.end(), isLarger5);

  for (auto iter = svec.begin(); iter != bound; ++iter) 
    cout << *iter << endl;
  
  return 0;
}   
   #+END_SRC

* Exercises Section 10.3.2
** Exercise 10.14
   #+BEGIN_QUOTE
   Write a lambda that takes two ~int~ s and returns their sum.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

int main()
{
  auto f = [](int a, int b)
    { return a + b; };

  cout << f(1, 2) << endl;

  return 0;
}   
   #+END_SRC

** Exercise 10.15
   #+BEGIN_QUOTE
   Write a lambda that captures an ~int~ from its enclosing function and takes
   an ~int~ parameter. The lambda should return the sum of the captured ~int~
   and the ~int~ parameter.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

int main()
{
  int a = 1;
  auto f = [a](int b)
    { return a + b; };

  cout << f(2) << endl;

  return 0;
}   
   #+END_SRC

** Exercise 10.16
   #+BEGIN_QUOTE
   Write your own version of the ~biggies~ function using lambdas.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::stable_sort;
using std::unique; using std::find_if;
using std::for_each;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

// return the plural version of word if ctr is greater than 1
string make_plural(size_t ctr, const string &word, const string &ending)
{
  return (ctr > 1) ? word + ending : word;
}

void biggies(vector<string> &words, vector<string>::size_type sz)
{
  elimDups(words);		// put words in alphabetical order and remove
				// duplicates
  
  // sort words by size, but maintain alphabetical order for words of the same size
  stable_sort(words.begin(), words.end(),
	      [](const string &a, const string &b)
	      { return a.size() < b.size(); });
  
  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // get an iterator to the first element whose size() is >= sz
  auto wc = find_if(words.begin(), words.end(),
		    [sz](const string &a) 
		    { return a.size() >= sz; });

  // compute the number of elements with size >= sz
  auto count = words.end() - wc;
  cout << count << " " << make_plural(count, "word", "s")
       << " of length " << sz << " or longer" << endl;

  // print words of the given size or longer, each one followed by a space
  for_each(wc, words.end(),
	   [](const string &s){ cout << s << " "; });
  cout << endl;
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  biggies(svec, 4);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}   
   #+END_SRC

** Exercise 10.17
   #+BEGIN_QUOTE
   Rewrite exercise 10.12 from § 10.3.1 (p. 387) to use a lambda in the call
   to sort instead of the ~compareIsbn~ function.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

struct Sales_data;
std::istream& read(std::istream &is, Sales_data &item);

struct Sales_data {
  // friend declarations for nonmember Sales_data operations added
  friend Sales_data add(const Sales_data &lhs, const Sales_data &rhs);
  friend std::istream& read(std::istream &is, Sales_data &item);
  friend std::ostream& print(std::ostream &os, const Sales_data &item);

  // other members and access specifiers as before
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &is) { read(is, *this); }

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

private:
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};


// definitions for nonmember parts of the Sales_data interface
Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

int main()
{
  Sales_data trans1("bbb");
  Sales_data trans2("aaa");
  Sales_data trans3("ccc");
  Sales_data trans4("bb");
  
  std::vector<Sales_data> vec = {trans1, trans2, trans3, trans4};
  std::sort(vec.begin(), vec.end(), 
	    [](const Sales_data &obj1, const Sales_data &obj2) 
	    { return obj1.isbn() < obj2.isbn(); });

  for (const auto &trans : vec) {
    std::cout << trans.isbn() << std::endl;
  }

  return 0;
}   
   #+END_SRC

** Exercise 10.18
   #+BEGIN_QUOTE
   Rewrite ~biggies~ to use ~partition~ instead of ~find_if~. We described the
   ~partition~ algorithm in exercise 10.13 in § 10.3.1 (p. 387).
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::stable_sort;
using std::unique; using std::partition;
using std::for_each;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

// return the plural version of word if ctr is greater than 1
string make_plural(size_t ctr, const string &word, const string &ending)
{
  return (ctr > 1) ? word + ending : word;
}

void biggies(vector<string> &words, vector<string>::size_type sz)
{
  elimDups(words);		// put words in alphabetical order and remove
				// duplicates
  
  auto wc = partition(words.begin(), words.end(),
		      [sz](const string &a) 
		      { return a.size() < sz; });

  for (const auto &str : words) cout << str << " ";
  cout << endl;
  
  // compute the number of elements with size >= sz
  auto count = words.end() - wc;
  cout << count << " " << make_plural(count, "word", "s")
       << " of length " << sz << " or longer" << endl;

  // print words of the given size or longer, each one followed by a space
  for_each(wc, words.end(),
	   [](const string &s){ cout << s << " "; });
  cout << endl;
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  biggies(svec, 4);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.19
   #+BEGIN_QUOTE
   Rewrite the previous exercise to use ~stable_partition~, which like
   ~stable_sort~ maintains the original element order in the paritioned
   sequence.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::unique; 
using std::stable_partition; using std::for_each;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

// return the plural version of word if ctr is greater than 1
string make_plural(size_t ctr, const string &word, const string &ending)
{
  return (ctr > 1) ? word + ending : word;
}

void biggies(vector<string> &words, vector<string>::size_type sz)
{
  elimDups(words);		// put words in alphabetical order and remove
				// duplicates
  
  auto wc = stable_partition(words.begin(), words.end(),
			     [sz](const string &a) 
			     { return a.size() < sz; });
  
  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // compute the number of elements with size >= sz
  auto count = words.end() - wc;
  cout << count << " " << make_plural(count, "word", "s")
       << " of length " << sz << " or longer" << endl;

  // print words of the given size or longer, each one followed by a space
  for_each(wc, words.end(),
	   [](const string &s){ cout << s << " "; });
  cout << endl;
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  biggies(svec, 4);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}   
   #+END_SRC

* Exercises Section 10.3.3
** Exercise 10.20
   #+BEGIN_QUOTE
   The library defines an algorithm named ~count_if~. Like ~find_if~, this
   function takes a pair of iterators denoting an input range and a predicate
   that it applies to each element in the given range. ~count_if~ returns a
   count of how often the predicate is true. Use count_if to rewrite the portion
   of our program that counted how many words are greater than length 6.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::count_if;

int main()
{
  vector<string> svec = {"hello", "world", "university", "of", "manchester"};

  auto cnt = count_if(svec.begin(), svec.end(),
		      [](const string &s)
		      { return s.size() > 6; });
  
  cout << cnt << " words are greater than length 6" << endl;

  return 0;
}   
   #+END_SRC

** Exercise 10.21
   #+BEGIN_QUOTE
   Write a lambda that captures a local ~int~ variable and decrements that
   variable until it reaches 0. Once the variable is 0 additional calls should
   no longer decrement the variable. The lambda should return a ~bool~ that
   indicates whether the captured variable is 0.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

int main()
{
  int ival = 10;

  auto f = [&ival] () -> bool { --ival; return ival == 0; };

  while (!f()) cout << ival << endl;
  
  return 0;
}   
   #+END_SRC

* Exercises Section 10.3.4
** Exercise 10.22
   #+BEGIN_QUOTE
   Rewrite the program to count words of size 6 or less using functions in place
   of the lambdas.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::count_if;

#include <functional>
using namespace std::placeholders;
using std::bind;

bool isShorter(const string& s, string::size_type sz) {
  return s.size() <= sz;
}

int main()
{
  vector<string> svec = {"hello", "world", "university", "of", "manchester"};

  auto cnt = count_if(svec.begin(), svec.end(), bind(isShorter, _1, 6));
  
  cout << cnt << " words are not greater than length 6" << endl;

  return 0;
}   
   #+END_SRC

** Exercise 10.23
   #+BEGIN_QUOTE
   How many arguments does ~bind~ take?
   #+END_QUOTE

   The general form of a call to ~bind~ is: ~auto newCallable = bind(callable,
   arg_list);~ where newCallable is itself a callable object and arg_list is a
   comma-separated list of arguments that correspond to the parameters of the
   given callable. That is, when we call newCallable , newCallable calls
   callable, passing the arguments in arg_list.

** Exercise 10.24
   #+BEGIN_QUOTE
   Use bind and check_size to find the first element in a vector of ints that
   has a value greater than the length of a specified string value.
   #+END_QUOTE

** Exercise 10.25
   #+BEGIN_QUOTE
   In the exercises for § 10.3.2 (p. 392) you wrote a version of biggies that
   uses partition. Rewrite that function to use check_size and bind.
   #+END_QUOTE
