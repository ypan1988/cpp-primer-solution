* Exercises Section 10.1
** Exercise 10.1
   #+BEGIN_QUOTE
   The ~algorithm~ header defines a function named ~count~ that, like ~find~,
   takes a pair of iterators and a value. ~count~ returns a count of how often
   that value appears. Read a sequence of ~int~ s into a ~vector~ and print the
   ~count~ of how many elements have a given value.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::count;

int main()
{
  vector<int> ivec = {1, 1, 1, 1, 2, 2, 2, 3, 3, 4};

  int ival = 1;
  cout << count(ivec.cbegin(), ivec.cend(), ival)
       << " elements have value " << ival << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.2
   #+BEGIN_QUOTE
   Repeat the previous program, but read values into a list of ~string~ s.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::count;

int main()
{
  vector<string> svec = {"aaa", "aaa", "aaa", "aaa", "bbb", "bbb", "bbb", "ccc",
                         "ccc", "ddd"};

  string s = "aaa";
  cout << count(svec.cbegin(), svec.cend(), s)
       << " strings have value " << s << endl;

  return 0;
}
   #+END_SRC

* Exercises Section 10.2.1
** Exercise 10.3
   #+BEGIN_QUOTE
   Use ~accumulate~ to sum the elements in a ~vector<int>~ .
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::accumulate;

int main()
{
  vector<int> ivec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  int sum = accumulate(ivec.cbegin(), ivec.cend(), 0);
  cout << "sum: "<< sum << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.4
   #+BEGIN_QUOTE
   Assuming ~v~ is a ~vector<double>~, what, if anything, is wrong with calling
   ~accumulate(v.cbegin(), v.cend(), 0)~?
   #+END_QUOTE

   The third argument of ~accumulate~ should be replace with 0.0

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::accumulate;

int main()
{
  vector<double> ivec = {1.1, 2.2, 3.3};

  double sum = accumulate(ivec.cbegin(), ivec.cend(), 0.0);
  cout << "sum: "<< sum << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.5
   #+BEGIN_QUOTE
   In the call to equal on rosters, what would happen if both rosters held
   C-style strings, rather than library strings?
   #+END_QUOTE

   For such case, ~std::equal~ is going to compare the address values rather
   than the ~string~ values. So the result is not the same as ~std::string~. Try
   to avoid coding this way.

* Exercises Section 10.2.2
** Exercise 10.6
   #+BEGIN_QUOTE
   Using ~fill_n~, write a program to set a sequence of ~int~ values to 0.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::fill_n;

int main()
{
  vector<int> ivec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  fill_n(ivec.begin(), ivec.size(), 0);

  for (auto ival : ivec)
    cout << ival << " ";

  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.7
   #+BEGIN_QUOTE
   Determine if there are any errors in the following programs and, if so,
   correct the error(s):
   + (a)
     #+BEGIN_SRC C++
vector<int> vec; list<int> lst; int i;
while (cin >> i)
  lst.push_back(i);
copy(lst.cbegin(), lst.cend(), vec.begin());
     #+END_SRC
   + (b)
     #+BEGIN_SRC C++
vector<int> vec;
vec.reserve(10); // reserve is covered in § 9.4 (p. 356)
fill_n(vec.begin(), 10, 0);
     #+END_SRC
   #+END_QUOTE

   + (a) incorrect. ~copy~ assumes that the second sequence is at least as large
     as the first.

     fix: ~copy(lst.cbegin(), lst.cend(), back_inserter(vec.begin()));~

   + (b) incorrect. ~fill_n~ assumes that it is safe to write the specified
     number of elements.

     fix: ~fill_n(back_inserter(vec), 10, 0)~

** Exercise 10.8
   #+BEGIN_QUOTE
   We said that algorithms do not change the size of the containers over which
   they operate. Why doesn’t the use of ~back_inserter~ invalidate this claim?
   #+END_QUOTE

   ~back_inserter~ takes a reference to a container and returns an insert
   iterator bound to that container. When we assign through that iterator, the
   assignment calls ~push_back~ to add an element with the given value to the
   container.

* Exercises Section 10.2.3
** Exercise 10.9
   #+BEGIN_QUOTE
   Implement your own version of ~elimDups~. Test your program by printing the
   ~vector~ after you read the input, after the call to ~unique~, and after the
   call to ~erase~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::unique;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  elimDups(svec);
  
  for (const auto &str : svec) cout << str << " ";
  cout << endl;
  
  return 0;
}   
   #+END_SRC

** Exercise 10.10
   #+BEGIN_QUOTE
   Why do you think the algorithms don’t change the size of containers?
   #+END_QUOTE

   The library algorithms operate on iterators, not containers. Therefore, an
   algorithm cannot (directly) add or remove elements.

* Exercises Section 10.3.1
** Exercise 10.11
   #+BEGIN_QUOTE
   Write a program that uses ~stable_sort~ and ~isShorter~ to sort a ~vector~
   passed to your version of ~elimDups~. Print the vector to verify that your
   program is correct.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::stable_sort;
using std::unique;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)
{
  return s1.size() < s2.size();
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  elimDups(svec);
  
  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  stable_sort(svec.begin(), svec.end(), isShorter);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}   
   #+END_SRC

** Exercise 10.12
   #+BEGIN_QUOTE
   Write a function named compareIsbn that compares the isbn() members of two
   Sales_data objects. Use that function to sort a vector that holds Sales_data
   objects.
   #+END_QUOTE

** Exercise 10.13
   #+BEGIN_QUOTE
   The library defines an algorithm named partition that takes a predicate and
   partitions the container so that values for which the predicate is true
   appear in the first part and those for which the predicate is false appear in
   the second part. The algorithm returns an iterator just past the last element
   for which the predicate returned true. Write a function that takes a string
   and returns a bool indicating whether the string has five characters or
   more. Use that function to partition words. Print the elements that have five
   or more characters.
   #+END_QUOTE
