* Exercises Section 10.1
** Exercise 10.1
   #+BEGIN_QUOTE
   The ~algorithm~ header defines a function named ~count~ that, like ~find~,
   takes a pair of iterators and a value. ~count~ returns a count of how often
   that value appears. Read a sequence of ~int~ s into a ~vector~ and print the
   ~count~ of how many elements have a given value.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::count;

int main()
{
  vector<int> ivec = {1, 1, 1, 1, 2, 2, 2, 3, 3, 4};

  int ival = 1;
  cout << count(ivec.cbegin(), ivec.cend(), ival)
       << " elements have value " << ival << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.2
   #+BEGIN_QUOTE
   Repeat the previous program, but read values into a list of ~string~ s.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::count;

int main()
{
  vector<string> svec = {"aaa", "aaa", "aaa", "aaa", "bbb", "bbb", "bbb", "ccc",
                         "ccc", "ddd"};

  string s = "aaa";
  cout << count(svec.cbegin(), svec.cend(), s)
       << " strings have value " << s << endl;

  return 0;
}
   #+END_SRC

* Exercises Section 10.2.1
** Exercise 10.3
   #+BEGIN_QUOTE
   Use ~accumulate~ to sum the elements in a ~vector<int>~ .
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::accumulate;

int main()
{
  vector<int> ivec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  int sum = accumulate(ivec.cbegin(), ivec.cend(), 0);
  cout << "sum: "<< sum << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.4
   #+BEGIN_QUOTE
   Assuming ~v~ is a ~vector<double>~, what, if anything, is wrong with calling
   ~accumulate(v.cbegin(), v.cend(), 0)~?
   #+END_QUOTE

   The third argument of ~accumulate~ should be replace with 0.0

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::accumulate;

int main()
{
  vector<double> ivec = {1.1, 2.2, 3.3};

  double sum = accumulate(ivec.cbegin(), ivec.cend(), 0.0);
  cout << "sum: "<< sum << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.5
   #+BEGIN_QUOTE
   In the call to equal on rosters, what would happen if both rosters held
   C-style strings, rather than library strings?
   #+END_QUOTE

   For such case, ~std::equal~ is going to compare the address values rather
   than the ~string~ values. So the result is not the same as ~std::string~. Try
   to avoid coding this way.

* Exercises Section 10.2.2
** Exercise 10.6
   #+BEGIN_QUOTE
   Using ~fill_n~, write a program to set a sequence of ~int~ values to 0.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::fill_n;

int main()
{
  vector<int> ivec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  fill_n(ivec.begin(), ivec.size(), 0);

  for (auto ival : ivec)
    cout << ival << " ";

  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.7
   #+BEGIN_QUOTE
   Determine if there are any errors in the following programs and, if so,
   correct the error(s):
   + (a)
     #+BEGIN_SRC C++
vector<int> vec; list<int> lst; int i;
while (cin >> i)
  lst.push_back(i);
copy(lst.cbegin(), lst.cend(), vec.begin());
     #+END_SRC
   + (b)
     #+BEGIN_SRC C++
vector<int> vec;
vec.reserve(10); // reserve is covered in § 9.4 (p. 356)
fill_n(vec.begin(), 10, 0);
     #+END_SRC
   #+END_QUOTE

   + (a) incorrect. ~copy~ assumes that the second sequence is at least as large
     as the first.

     fix: ~copy(lst.cbegin(), lst.cend(), back_inserter(vec.begin()));~

   + (b) incorrect. ~fill_n~ assumes that it is safe to write the specified
     number of elements.

     fix: ~fill_n(back_inserter(vec), 10, 0)~

** Exercise 10.8
   #+BEGIN_QUOTE
   We said that algorithms do not change the size of the containers over which
   they operate. Why doesn’t the use of ~back_inserter~ invalidate this claim?
   #+END_QUOTE

   ~back_inserter~ takes a reference to a container and returns an insert
   iterator bound to that container. When we assign through that iterator, the
   assignment calls ~push_back~ to add an element with the given value to the
   container.

* Exercises Section 10.2.3
** Exercise 10.9
   #+BEGIN_QUOTE
   Implement your own version of ~elimDups~. Test your program by printing the
   ~vector~ after you read the input, after the call to ~unique~, and after the
   call to ~erase~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::unique;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  elimDups(svec);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.10
   #+BEGIN_QUOTE
   Why do you think the algorithms don’t change the size of containers?
   #+END_QUOTE

   The library algorithms operate on iterators, not containers. Therefore, an
   algorithm cannot (directly) add or remove elements.

* Exercises Section 10.3.1
** Exercise 10.11
   #+BEGIN_QUOTE
   Write a program that uses ~stable_sort~ and ~isShorter~ to sort a ~vector~
   passed to your version of ~elimDups~. Print the vector to verify that your
   program is correct.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::stable_sort;
using std::unique;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)
{
  return s1.size() < s2.size();
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  elimDups(svec);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  stable_sort(svec.begin(), svec.end(), isShorter);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.12
   #+BEGIN_QUOTE
   Write a function named ~compareIsbn~ that compares the ~isbn()~ members of
   two ~Sales_data~ objects. Use that function to sort a ~vector~ that holds
   ~Sales_data~ objects.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

struct Sales_data;
std::istream& read(std::istream &is, Sales_data &item);

struct Sales_data {
  // friend declarations for nonmember Sales_data operations added
  friend Sales_data add(const Sales_data &lhs, const Sales_data &rhs);
  friend std::istream& read(std::istream &is, Sales_data &item);
  friend std::ostream& print(std::ostream &os, const Sales_data &item);

  // other members and access specifiers as before
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &is) { read(is, *this); }

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

private:
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};


// definitions for nonmember parts of the Sales_data interface
Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

bool compareIsbn(const Sales_data &obj1, const Sales_data &obj2) {
  return obj1.isbn() < obj2.isbn();
}

int main()
{
  Sales_data trans1("bbb");
  Sales_data trans2("aaa");
  Sales_data trans3("ccc");
  Sales_data trans4("bb");

  std::vector<Sales_data> vec = {trans1, trans2, trans3, trans4};
  std::sort(vec.begin(), vec.end(), compareIsbn);

  for (const auto &trans : vec) {
    std::cout << trans.isbn() << std::endl;
  }

  return 0;
}
   #+END_SRC

** Exercise 10.13
   #+BEGIN_QUOTE
   The library defines an algorithm named ~partition~ that takes a predicate and
   partitions the container so that values for which the predicate is ~true~
   appear in the first part and those for which the predicate is ~false~ appear
   in the second part. The algorithm returns an iterator just past the last
   element for which the predicate returned ~true~. Write a function that takes
   a ~string~ and returns a ~bool~ indicating whether the ~string~ has five
   characters or more. Use that function to partition ~words~. Print the
   elements that have five or more characters.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::partition;

bool isLarger5(const string &s)
{
  return s.size() >= 5;
}

int main()
{
  vector<string> svec = {"aaa", "Hello", "bbb", "world!!!", "ccc"};
  auto bound = partition(svec.begin(), svec.end(), isLarger5);

  for (auto iter = svec.begin(); iter != bound; ++iter)
    cout << *iter << endl;

  return 0;
}
   #+END_SRC

* Exercises Section 10.3.2
** Exercise 10.14
   #+BEGIN_QUOTE
   Write a lambda that takes two ~int~ s and returns their sum.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

int main()
{
  auto f = [](int a, int b)
    { return a + b; };

  cout << f(1, 2) << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.15
   #+BEGIN_QUOTE
   Write a lambda that captures an ~int~ from its enclosing function and takes
   an ~int~ parameter. The lambda should return the sum of the captured ~int~
   and the ~int~ parameter.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

int main()
{
  int a = 1;
  auto f = [a](int b)
    { return a + b; };

  cout << f(2) << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.16
   #+BEGIN_QUOTE
   Write your own version of the ~biggies~ function using lambdas.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::stable_sort;
using std::unique; using std::find_if;
using std::for_each;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

// return the plural version of word if ctr is greater than 1
string make_plural(size_t ctr, const string &word, const string &ending)
{
  return (ctr > 1) ? word + ending : word;
}

void biggies(vector<string> &words, vector<string>::size_type sz)
{
  elimDups(words);		// put words in alphabetical order and remove
				// duplicates

  // sort words by size, but maintain alphabetical order for words of the same size
  stable_sort(words.begin(), words.end(),
	      [](const string &a, const string &b)
	      { return a.size() < b.size(); });

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // get an iterator to the first element whose size() is >= sz
  auto wc = find_if(words.begin(), words.end(),
		    [sz](const string &a)
		    { return a.size() >= sz; });

  // compute the number of elements with size >= sz
  auto count = words.end() - wc;
  cout << count << " " << make_plural(count, "word", "s")
       << " of length " << sz << " or longer" << endl;

  // print words of the given size or longer, each one followed by a space
  for_each(wc, words.end(),
	   [](const string &s){ cout << s << " "; });
  cout << endl;
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  biggies(svec, 4);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.17
   #+BEGIN_QUOTE
   Rewrite exercise 10.12 from § 10.3.1 (p. 387) to use a lambda in the call
   to sort instead of the ~compareIsbn~ function.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

struct Sales_data;
std::istream& read(std::istream &is, Sales_data &item);

struct Sales_data {
  // friend declarations for nonmember Sales_data operations added
  friend Sales_data add(const Sales_data &lhs, const Sales_data &rhs);
  friend std::istream& read(std::istream &is, Sales_data &item);
  friend std::ostream& print(std::ostream &os, const Sales_data &item);

  // other members and access specifiers as before
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &is) { read(is, *this); }

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

private:
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};


// definitions for nonmember parts of the Sales_data interface
Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

int main()
{
  Sales_data trans1("bbb");
  Sales_data trans2("aaa");
  Sales_data trans3("ccc");
  Sales_data trans4("bb");

  std::vector<Sales_data> vec = {trans1, trans2, trans3, trans4};
  std::sort(vec.begin(), vec.end(),
	    [](const Sales_data &obj1, const Sales_data &obj2)
	    { return obj1.isbn() < obj2.isbn(); });

  for (const auto &trans : vec) {
    std::cout << trans.isbn() << std::endl;
  }

  return 0;
}
   #+END_SRC

** Exercise 10.18
   #+BEGIN_QUOTE
   Rewrite ~biggies~ to use ~partition~ instead of ~find_if~. We described the
   ~partition~ algorithm in exercise 10.13 in § 10.3.1 (p. 387).
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::stable_sort;
using std::unique; using std::partition;
using std::for_each;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

// return the plural version of word if ctr is greater than 1
string make_plural(size_t ctr, const string &word, const string &ending)
{
  return (ctr > 1) ? word + ending : word;
}

void biggies(vector<string> &words, vector<string>::size_type sz)
{
  elimDups(words);		// put words in alphabetical order and remove
				// duplicates

  auto wc = partition(words.begin(), words.end(),
		      [sz](const string &a)
		      { return a.size() < sz; });

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // compute the number of elements with size >= sz
  auto count = words.end() - wc;
  cout << count << " " << make_plural(count, "word", "s")
       << " of length " << sz << " or longer" << endl;

  // print words of the given size or longer, each one followed by a space
  for_each(wc, words.end(),
	   [](const string &s){ cout << s << " "; });
  cout << endl;
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  biggies(svec, 4);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.19
   #+BEGIN_QUOTE
   Rewrite the previous exercise to use ~stable_partition~, which like
   ~stable_sort~ maintains the original element order in the paritioned
   sequence.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::unique;
using std::stable_partition; using std::for_each;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

// return the plural version of word if ctr is greater than 1
string make_plural(size_t ctr, const string &word, const string &ending)
{
  return (ctr > 1) ? word + ending : word;
}

void biggies(vector<string> &words, vector<string>::size_type sz)
{
  elimDups(words);		// put words in alphabetical order and remove
				// duplicates

  auto wc = stable_partition(words.begin(), words.end(),
			     [sz](const string &a)
			     { return a.size() < sz; });

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // compute the number of elements with size >= sz
  auto count = words.end() - wc;
  cout << count << " " << make_plural(count, "word", "s")
       << " of length " << sz << " or longer" << endl;

  // print words of the given size or longer, each one followed by a space
  for_each(wc, words.end(),
	   [](const string &s){ cout << s << " "; });
  cout << endl;
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  biggies(svec, 4);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}
   #+END_SRC

* Exercises Section 10.3.3
** Exercise 10.20
   #+BEGIN_QUOTE
   The library defines an algorithm named ~count_if~. Like ~find_if~, this
   function takes a pair of iterators denoting an input range and a predicate
   that it applies to each element in the given range. ~count_if~ returns a
   count of how often the predicate is true. Use count_if to rewrite the portion
   of our program that counted how many words are greater than length 6.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::count_if;

int main()
{
  vector<string> svec = {"hello", "world", "university", "of", "manchester"};

  auto cnt = count_if(svec.begin(), svec.end(),
		      [](const string &s)
		      { return s.size() > 6; });

  cout << cnt << " words are greater than length 6" << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.21
   #+BEGIN_QUOTE
   Write a lambda that captures a local ~int~ variable and decrements that
   variable until it reaches 0. Once the variable is 0 additional calls should
   no longer decrement the variable. The lambda should return a ~bool~ that
   indicates whether the captured variable is 0.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

int main()
{
  int ival = 10;

  auto f = [&ival] () -> bool { --ival; return ival == 0; };

  while (!f()) cout << ival << endl;

  return 0;
}
   #+END_SRC

* Exercises Section 10.3.4
** Exercise 10.22
   #+BEGIN_QUOTE
   Rewrite the program to count words of size 6 or less using functions in place
   of the lambdas.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::count_if;

#include <functional>
using namespace std::placeholders;
using std::bind;

bool isShorter(const string& s, string::size_type sz) {
  return s.size() <= sz;
}

int main()
{
  vector<string> svec = {"hello", "world", "university", "of", "manchester"};

  auto cnt = count_if(svec.begin(), svec.end(), bind(isShorter, _1, 6));

  cout << cnt << " words are not greater than length 6" << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.23
   #+BEGIN_QUOTE
   How many arguments does ~bind~ take?
   #+END_QUOTE

   The general form of a call to ~bind~ is: ~auto newCallable = bind(callable,
   arg_list);~ where newCallable is itself a callable object and arg_list is a
   comma-separated list of arguments that correspond to the parameters of the
   given callable. That is, when we call newCallable , newCallable calls
   callable, passing the arguments in arg_list.

** Exercise 10.24
   #+BEGIN_QUOTE
   Use ~bind~ and ~check_size~ to find the first element in a ~vector~ of ~int~
   s that has a value greater than the length of a specified ~string~ value.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::find_if;

#include <functional>
using namespace std::placeholders;
using std::bind;

bool check_size(const string &s, string::size_type sz)
{
  return s.size() < sz;
}

int main()
{
  vector<int> ivec = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
  string s("hello");

  auto iter = find_if(ivec.begin(), ivec.end(), bind(check_size, s, _1));

  cout << *iter << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.25
   #+BEGIN_QUOTE
   In the exercises for § 10.3.2 (p. 392) you wrote a version of ~biggies~ that
   uses ~partition~. Rewrite that function to use ~check_size~ and ~bind~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::stable_sort;
using std::unique; using std::partition;
using std::for_each;

#include <functional>
using namespace std::placeholders;
using std::bind;

void elimDups(vector<string> &words)
{
  // sort words alphabetically so we can find the duplicates
  sort(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // unique reorders the input range so that each word appears once in the
  // front portion of the range and returns an iterator one past the unique range
  auto end_unique = unique(words.begin(), words.end());

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // erase uses a vector operation to remove the nonunique elements
  words.erase(end_unique, words.end());
}

bool check_size(const string &s, string::size_type sz)
{
  return s.size() < sz;
}

// return the plural version of word if ctr is greater than 1
string make_plural(size_t ctr, const string &word, const string &ending)
{
  return (ctr > 1) ? word + ending : word;
}

void biggies(vector<string> &words, vector<string>::size_type sz)
{
  elimDups(words);		// put words in alphabetical order and remove
				// duplicates

  auto wc = partition(words.begin(), words.end(), bind(check_size, _1, sz));

  for (const auto &str : words) cout << str << " ";
  cout << endl;

  // compute the number of elements with size >= sz
  auto count = words.end() - wc;
  cout << count << " " << make_plural(count, "word", "s")
       << " of length " << sz << " or longer" << endl;

  // print words of the given size or longer, each one followed by a space
  for_each(wc, words.end(),
	   [](const string &s){ cout << s << " "; });
  cout << endl;
}

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  biggies(svec, 4);

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  return 0;
}
   #+END_SRC

* Exercises Section 10.4.1
** Exercise 10.26
   #+BEGIN_QUOTE
   Explain the differences among the three kinds of insert iterators.
   #+END_QUOTE

   There are three kinds of inserters. Each differs from the others as to where
   elements are inserted:

   + ~back_inserter~ creates an iterator that uses ~push_back~.
   + ~front_inserter~ creates an iterator that uses ~push_front~.
   + ~inserter~ creates an iterator that uses ~insert~. This function takes a
     second argument, which must be an iterator into the given
     container. Elements are inserted ahead of the element denoted by the given
     iterator.

** Exercise 10.27
   #+BEGIN_QUOTE
   In addition to ~unique~ (§ 10.2.3, p. 384), the library defines function
   named ~unique_copy~ that takes a third iterator denoting a destination into
   which to copy the unique elements. Write a program that uses ~unique_copy~ to
   copy the unique elements from a vector into an initially empty list.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <list>
using std::list;

#include <algorithm>
using std::sort; using std::unique_copy;

#include <iterator>
using std::back_inserter;

int main()
{
  vector<string> svec = {"the", "quick", "red", "fox", "jumps", "over", "the",
			 "slow", "red", "turtle"};

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  sort(svec.begin(), svec.end());

  for (const auto &str : svec) cout << str << " ";
  cout << endl;

  list<string> lst;
  unique_copy(svec.begin(), svec.end(), back_inserter(lst));

  for (const auto &str : lst) cout << str << " ";
  cout << endl;

  return 0;
}
   #+END_SRC

** Exercise 10.28
   #+BEGIN_QUOTE
   Copy a ~vector~ that holds the values from 1 to 9 inclusive, into three other
   containers. Use an ~inserter~, a ~back_inserter~, and a ~front_inserter~,
   respectivly to add elements to these containers. Predict how the output
   sequence varies by the kind of inserter and verify your predictions by
   running your programs.
   #+END_QUOTE

   Therefore, ~front_inserter~ yields an iterator that reverses the order of the
   sequence that it inserts; ~inserter~ and ~back_inserter~ don’t.

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <list>
using std::list;

#include <algorithm>
using std::copy;

#include <iterator>
using std::inserter;
using std::back_inserter;
using std::front_inserter;

int main()
{
  vector<int> ivec = { 1, 2, 3, 4, 5, 6, 7, 8, 9};

  cout << "vector:" << endl;
  for (const auto &ival : ivec) cout << ival << " ";
  cout << endl;

  list<int> ilst1, ilst2, ilst3;

  cout << "inserter:" << endl;
  copy(ivec.begin(), ivec.end(), inserter(ilst1, ilst1.begin()));
  for (const auto &ival : ilst1) cout << ival << " ";
  cout << endl;

  cout << "back_inserter:" << endl;
  copy(ivec.begin(), ivec.end(), back_inserter(ilst2));
  for (const auto &ival : ilst2) cout << ival << " ";
  cout << endl;

  cout << "front_inserter:" << endl;
  copy(ivec.begin(), ivec.end(), front_inserter(ilst3));
  for (const auto &ival : ilst3) cout << ival << " ";
  cout << endl;

  return 0;
}
   #+END_SRC

* Exercises Section 10.4.2
** Exercise 10.29
   #+BEGIN_QUOTE
   Write a program using stream iterators to read a text file into a ~vector~ of
   ~string~ s.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <iterator>
using std::istream_iterator;

int main()
{
    istream_iterator<string> in_iter(cin), eof;  // read strings from cin
    vector<string> vec(in_iter, eof);            // construct vec from an iterator range

    for (const auto &s : vec)
        cout << s << endl;

    return 0;
}
   #+END_SRC

** Exercise 10.30
   #+BEGIN_QUOTE
   Use stream iterators, ~sort~, and ~copy~ to read a sequence of integers from
   the standard input, sort them, and then write them back to the standard
   output.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::copy;

#include <iterator>
using std::istream_iterator; using std::ostream_iterator;

int main()
{
    istream_iterator<int> in_iter(cin), eof; // read ints from cin
    vector<int> vec(in_iter, eof); // construct vec from an iterator range

    sort(vec.begin(), vec.end());

    ostream_iterator<int> out_iter(cout, " ");
    copy(vec.begin(), vec.end(), out_iter);
    cout << endl;

    return 0;
}
   #+END_SRC

** Exercise 10.31
   #+BEGIN_QUOTE
   Update the program from the previous exercise so that it prints only the
   unique elements. Your program should use ~unqiue_copy~ (§ 10.4.1, p. 403).
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin; using std::cout; using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort; using std::unique_copy;

#include <iterator>
using std::istream_iterator; using std::ostream_iterator;

int main()
{
    istream_iterator<int> in_iter(cin), eof; // read ints from cin
    vector<int> vec(in_iter, eof); // construct vec from an iterator range

    sort(vec.begin(), vec.end());

    ostream_iterator<int> out_iter(cout, " ");
    unique_copy(vec.begin(), vec.end(), out_iter);
    cout << endl;

    return 0;
}
   #+END_SRC

** Exercise 10.32
   #+BEGIN_QUOTE
   Rewrite the bookstore problem from § 1.6 (p. 24) using a ~vector~ to hold the
   transactions and various algorithms to do the processing. Use ~sort~ with
   your ~compareIsbn~ function from § 10.3.1 (p. 387) to arrange the
   transactions in order, and then use ~find~ and ~accumulate~ to do the sum.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin;
using std::cout;
using std::endl;

#include <vector>
using std::vector;

#include <algorithm>
using std::sort;
using std::find_if;
using std::accumulate;

#include <iterator>
using std::istream_iterator;

#include "Sales_item.h"

int main()
{
  istream_iterator<Sales_item> in_iter(cin), eof;
  vector<Sales_item> vec(in_iter, eof);

  sort(vec.begin(), vec.end(),
       [](const Sales_item &obj1, const Sales_item &obj2)
       { return obj1.isbn() < obj2.isbn(); });

  Sales_item sum;
  auto iter = vec.cbegin();
  while (iter != vec.cend()) {
    auto start = iter;
    auto end = vec.cend();
    end = find_if(start, end,
		  [start](const Sales_item &trans) 
		  { return trans.isbn() != start->isbn(); });
    cout << accumulate(start, end, Sales_item(start->isbn())) << endl;
    iter = end;
  }

  return 0;
}   
   #+END_SRC

** Exercise 10.33
   #+BEGIN_QUOTE
   Write a program that takes the names of an input file and two output files.
   The input file should hold integers. Using an ~istream_iterator~ read the
   input file. Using ~ostream_iterators~, write the odd numbers into the first
   output file. Each value should be followed by a space. Write the even numbers
   into the second file. Each of these values should be placed on a separate
   line.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <string>
using std::string;

#include <fstream>
using std::ifstream;
using std::ofstream;

#include <algorithm>
using std::for_each;

#include <iterator>
using std::istream_iterator;
using std::ostream_iterator;

int main()
{
  string ifile = "./data/integers";
  ifstream in(ifile);
  
  istream_iterator<int> in_iter(in), eof;

  string ofile1 = "output1";
  string ofile2 = "output2";
  ofstream out1(ofile1), out2(ofile2);

  ostream_iterator<int> out_iter1(out1, " ");
  ostream_iterator<int> out_iter2(out2, "\n");

  for_each(in_iter, eof, 
	   [&out_iter1, &out_iter2](const int i)
	   { *(i % 2 ? out_iter1 : out_iter2)++ = i; });

  return 0;
}   
   #+END_SRC

* Exercises Section 10.4.3
** Exercise 10.34
   #+BEGIN_QUOTE
   Use ~reverse_iterators~ to print a ~vector~ in reverse order.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
using std::cout;

#include <vector>
using std::vector;

#include <algorithm>
using std::copy;

#include <iterator>
using std::ostream_iterator;

int main()
{
  vector<int> ivec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  ostream_iterator<int> out_iter(cout, "\n");
  copy(ivec.crbegin(), ivec.crend(), out_iter);
  
  return 0;
}   
   #+END_SRC

** Exercise 10.35
   #+BEGIN_QUOTE
   Now print the elements in reverse order using ordinary iterators.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

int main()
{
  vector<int> ivec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

  auto iter = ivec.cend();
  while (iter != ivec.begin()) {
    cout << *(--iter) << endl;
  }
  
  return 0;
}   
   #+END_SRC

** Exercise 10.36
   #+BEGIN_QUOTE
   Use ~find~ to find the last element in a list of ~int~ s with value 0.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <list>
using std::list;

#include <algorithm>
using std::find;

int main()
{
  list<int> ilst = {1, 2, 3, 0, 4, 5, 6, 0, 7, 8, 9};

  auto zero = find(ilst.crbegin(), ilst.crend(), 0);
  auto iter = zero.base();
  while (iter != ilst.end()) {
    cout << *iter++ << endl;
  }
  
  return 0;
}   
   #+END_SRC

** Exercise 10.37
   #+BEGIN_QUOTE
   Given a vector that has ten elements, copy the elements from positions 3
   through 7 in reverse order to a list.
   #+END_QUOTE
