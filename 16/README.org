* Exercises Section 16.1.1
** Exercise 16.1
   #+BEGIN_QUOTE
   Define instantiation.
   #+END_QUOTE

   When the compiler instantiates a template, it creates a new “instance” of the
   template using the actual template argument(s) in place of the corresponding
   template parameter(s). These compiler-generated functions are generally
   referred to as an instantiation of the template.

** Exercise 16.2
   #+BEGIN_QUOTE
   Write and test your own versions of the compare functions.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <vector>
using std::vector;

template <typename T>
int compare(const T &v1, const T &v2)
{
  if (v1 < v2) return -1;
  if (v2 < v1) return 1;
  return 0;
}

int main()
{
  cout << compare(1, 0) << endl;

  vector<int> vec1{1, 2, 3}, vec2{4, 5, 6};
  cout << compare(vec1, vec2) << endl;

  return 0;
}
   #+END_SRC

** Exercise 16.3
   #+BEGIN_QUOTE
   Call your ~compare~ function on two ~Sales_data~ objects to see how your
   compiler handles errors during instantiation.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

class Sales_data { };

template <typename T>
int compare(const T &v1, const T &v2)
{
  if (v1 < v2) return -1;
  if (v2 < v1) return 1;
  return 0;
}

int main()
{
  Sales_data data1, data2;
  // cout << compare(data1, data2) << endl;

  // error: no match for 'operator<' (operand types are 'const Sales_data' and
  // 'const Sales_data')

  return 0;
}
   #+END_SRC

** Exercise 16.4
   #+BEGIN_QUOTE
   Write a template that acts like the library ~find~ algorithm. The function
   will need two template type parameters, one to represent the function’s
   iterator parameters and the other for the type of the value. Use your
   function to find a given value in a ~vector<int>~ and in a ~list<string>~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

#include <vector>
using std::vector;

#include <list>
using std::list;

template <typename iterator, typename value_type>
iterator find(iterator first, iterator last, const value_type &value)
{
  while (*first != value && first != last) ++first;
  return first;
}

int main()
{
  vector<int> ivec = {1, 2, 3, 4, 5, 6, 7, 8, 9};
  cout << (ivec.cend() != find(ivec.begin(), ivec.end(), 5) ? "found" : "not found")
       << endl;

  list<string> slst = {"aa", "bb", "cc", "dd", "ee", "ff", "gg"};
  cout << (slst.cend() != find(slst.begin(), slst.end(), "zz") ? "found" : "not found")
       << endl;

  return 0;
}
   #+END_SRC

** Exercise 16.5
   #+BEGIN_QUOTE
   Write a template version of the ~print~ function from § 6.2.4 (p. 217) that
   takes a reference to an array and can handle arrays of any size and any
   element type.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
#include <string>

template <typename Array>
void print(const Array &a){
  for (const auto &elem : a)
    std::cout << elem << std::endl;
  std::cout << std::endl;
}

int main()
{
  int i[] = {1, 2, 3, 4, 5};
  char c[] = {'a', 'b', 'c', 'd', 'e'};
  std::string s[] = {"aa", "bb", "cc", "dd", "ee"};

  print(i);
  print(c);
  print(s);

  return 0;
}
   #+END_SRC

** Exercise 16.6
   #+BEGIN_QUOTE
   How do you think the library ~begin~ and ~end~ functions that take an array
   argument work? Define your own versions of these functions.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

template <typename T, unsigned N>
T* array_begin(T (&arr)[N])
{
  return arr;
}

template <typename T, unsigned N>
T* array_end(T (&arr)[N])
{
  return arr + N;
}

int main()
{
  string sa[] = {"aa", "bb", "cc", "dd"};
  cout << *(array_begin(sa) + 1) << endl;
  cout << *(array_end(sa) - 1) << endl;

  return 0;
}
   #+END_SRC

** Exercise 16.7
   #+BEGIN_QUOTE
   Write a ~constexpr~ template that returns the size of a given array.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

#include <string>
using std::string;

template <typename T, unsigned N>
constexpr unsigned get_array_size(const T (&arr)[N])
{
  return N;
}

int main()
{
  char ca[] = "abcd";
  cout << get_array_size(ca) << endl; // 5

  string sa[] = {"aa", "bb", "cc", "dd"};
  cout << get_array_size(sa) << endl; // 4

  return 0;
}
   #+END_SRC

** Exercise 16.8
   #+BEGIN_QUOTE
   In the “Key Concept” box on page 108, we noted that as a matter of habit C++
   programmers prefer using != to using <. Explain the rationale for this habit.
   #+END_QUOTE

   The reason is that more class defines "!=" rather than "<". Doing so can
   reduce the number of requirement of the class used with a template class.

* Exercises Section 16.1.2
** Exercise 16.9
   #+BEGIN_QUOTE
   What is a function template? What is a class template?
   #+END_QUOTE

   A *function template* is a formula from which we can generate type-specific
   versions of that function. A *class template* is a blueprint for generating
   classes. Class templates diff from function template in that the compiler
   cannot deduce the template parameter type(s) for a class template. Instead,
   to use a class template we must supply additional information inside angle
   brackets following the template's name. That extra information is the list of
   template arguments to use in place of the template parameters.

** Exercise 16.10
   #+BEGIN_QUOTE
   What happens when a class template is instantiated?
   #+END_QUOTE

** Exercise 16.11
   #+BEGIN_QUOTE
   The following definition of List is incorrect. How would you fix it?
   #+END_QUOTE
   #+BEGIN_SRC C++
template <typename elemType> class ListItem;
template <typename elemType> class List {
 public:
  List<elemType>();
  List<elemType>(const List<elemType> &);
  List<elemType>& operator=(const List<elemType> &);
  ~List();
  void insert(ListItem *ptr, elemType value);
 private:
  ListItem *front, *end;
};
   #+END_SRC

** Exercise 16.12
   #+BEGIN_QUOTE
   Write your own version of the Blob and BlobPtr templates. including the
   various const members that were not shown in the text.
   #+END_QUOTE

** Exercise 16.13
   #+BEGIN_QUOTE
   Explain which kind of friendship you chose for the equality and relational
   operators for BlobPtr.
   #+END_QUOTE

** Exercise 16.14
   #+BEGIN_QUOTE
   Write a Screen class template that uses nontype parameters to define the
   height and width of the Screen.
   #+END_QUOTE

** Exercise 16.15
   #+BEGIN_QUOTE
   Implement input and output operators for your Screen template. Which, if any,
   friends are necessary in class Screen to make the input and output operators
   work? Explain why each friend declaration, if any, was needed.
   #+END_QUOTE

** Exercise 16.16
   #+BEGIN_QUOTE
   Rewrite the StrVec class (§ 13.5, p. 526) as a template named Vec.
   #+END_QUOTE
