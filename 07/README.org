* Exercises Section 7.1.1
** Exercise 7.1
   #+BEGIN_QUOTE
   Write a version of the transaction-processing program from § 1.6 (p. 24)
   using the ~Sales_data~ class you defined for the exercises in § 2.6.1 (p.
   72).
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>

struct Sales_data {
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

int main()
{
  Sales_data total; // variable to hold data for the next transaction

  // read the first transaction and ensure that there are data to process
  if (std::cin >> total.bookNo >> total.units_sold >> total.revenue) {
    Sales_data trans;           // variable to hold the running sum
    // read and process the remaining transtraction
    while (std::cin >> trans.bookNo >> trans.units_sold >> trans.revenue) {
      // if we're still processing the same book
      if (total.bookNo == trans.bookNo) {
        // update the running total
        total.units_sold += trans.units_sold;
        total.revenue += trans.revenue;
      } else {
        // print results for the previous book
        std::cout << total.bookNo << " "
                  << total.units_sold << " "
                  << total.revenue << std::endl;
        total = trans;          // total now refers to the next book
      }
    }
    std::cout << total.bookNo << " "
              << total.units_sold << " "
              << total.revenue << std::endl;
  } else {
    // no input! warn the user
    std::cerr << "No data?!" << std::endl;
    return -1;                  // indicate failure
  }

  return 0;
}
   #+END_SRC
   
* Exercises Section 7.1.2
** Exercise 7.2
   #+BEGIN_QUOTE
   Add the ~combine~ and ~isbn~ members to the ~Sales_data~ class you wrote for
   the exercises in § 2.6.2 (p. 76).
   #+END_QUOTE

   #+BEGIN_SRC C++
// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was called
}

std::string 
Sales_data::isbn() const { 
  return bookNo; 
}   
   #+END_SRC

** Exercise 7.3
   #+BEGIN_QUOTE
   Revise your transaction-processing program from § 7.1.1 (p. 256) to use these
   members.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>

struct Sales_data {
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;

  // operations on Sales_data objects
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
};

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was called
}

int main()
{
  Sales_data total; // variable to hold data for the next transaction

  // read the first transaction and ensure that there are data to process
  if (std::cin >> total.bookNo >> total.units_sold >> total.revenue) {
    Sales_data trans;           // variable to hold the running sum
    // read and process the remaining transtraction
    while (std::cin >> trans.bookNo >> trans.units_sold >> trans.revenue) {
      // if we're still processing the same book
      if (total.isbn() == trans.isbn()) {
        // update the running total
        total.combine(trans);
      }
      else {
        // print results for the previous book
        std::cout << total.bookNo << " "
                  << total.units_sold << " "
                  << total.revenue << std::endl;
        total = trans;          // total now refers to the next book
      }
    }
    std::cout << total.bookNo << " "
              << total.units_sold << " "
              << total.revenue << std::endl;
  } else {
    // no input! warn the user
    std::cerr << "No data?!" << std::endl;
    return -1;                  // indicate failure
  }

  return 0;
}
   #+END_SRC

** Exercise 7.4
   #+BEGIN_QUOTE
   Write a class named ~Person~ that represents the name and address of a
   person. Use a ~string~ to hold each of these elements. Subsequent exercises
   will incrementally add features to this class.
   #+END_QUOTE

   #+BEGIN_SRC C++
class Person {
 private:
  std::string name;
  std::string address;
};   
   #+END_SRC

** Exercise 7.5
   #+BEGIN_QUOTE
   Provide operations in your ~Person~ class to return the name and address.
   Should these functions be ~const~? Explain your choice.
   #+END_QUOTE

   #+BEGIN_SRC C++
class Person {
 private:
  std::string name;
  std::string address;
 public:
  std::string get_name() const { return name; }
  std::string get_addr() const { return address; }
};   
   #+END_SRC

   The body of ~get_name~ and ~get_addr~ will not change the object to which
   ~this~ points, so these functions should be ~const~.

* Exercises Section 7.1.3
** Exercise 7.6
   #+BEGIN_QUOTE
   Define your own versions of the ~add~, ~read~, and ~print~ functions.
   #+END_QUOTE

   #+BEGIN_SRC C++
Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}
   #+END_SRC
 
** Exercise 7.7
   #+BEGIN_QUOTE
   Rewrite the transaction-processing program you wrote for the exercises in §
   7.1.2 (p. 260) to use these new functions.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>

struct Sales_data {
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;

  // operations on Sales_data objects
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;
};

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
				// called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}   

int main()
{
  Sales_data total; // variable to hold data for the next transaction

  // read the first transaction and ensure that there are data to process
  if (read(std::cin, total)) {
    Sales_data trans;           // variable to hold the running sum
    // read and process the remaining transtraction
    while (read(std::cin, trans)) {
      // if we're still processing the same book
      if (total.isbn() == trans.isbn()) {
	      // update the running total
	      total.combine(trans);	
      }
      else {
        // print results for the previous book
	      print(std::cout, total);
        std::cout << std::endl;
        total = trans;          // total now refers to the next book
      }
    }
    print(std::cout, total);
    std::cout << std::endl;
  } else {
    // no input! warn the user
    std::cerr << "No data?!" << std::endl;
    return -1;                  // indicate failure
  }

  return 0;
}   
  
 #+END_SRC

** Exercise 7.8
   #+BEGIN_QUOTE
   Why does ~read~ define its ~Sales_data~ parameter as a plain reference and
   ~print~ define its parameter as a reference to ~const~?
   #+END_QUOTE
   
   ~Sales_data~ is defined as a plain reference in ~read~ since we may change
   its data members while it is defined as a reference to ~const~ in ~print~
   since we don't want to write to its data members.

** Exercise 7.9
   #+BEGIN_QUOTE
   Add operations to read and print ~Person~ objects to the code you wrote for
   the exercises in § 7.1.2 (p. 260).
   #+END_QUOTE

   #+BEGIN_SRC C++
std::istream&
read(std::istream &is, Person &person) {
  is >> person.name >> person.address;
  return is;
}

std::ostream&
print(std::ostream &os, Person &person) {
  os << person.name << " "
     << person.address << " " 
     << std::endl;
}   
   #+END_SRC

** Exercise 7.10
   #+BEGIN_QUOTE
   What does the condition in the following ~if~ statement do?

   ~if (read(read(cin, data1), data2))~
   #+END_QUOTE

   The condition of the ~if~ would check if it is successful to read two
   Sales_data objects.

* Exercises Section 7.1.4
** Exercise 7.11
   #+BEGIN_QUOTE
   Add constructors to your ~Sales_data~ class and write a program to use each
   of the constructors.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
#include <string>

struct Sales_data {
  // constructors added
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &);

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

Sales_data::Sales_data(std::istream &is)
{
  read(is, *this);
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

int main()
{
  Sales_data item1;
  print(std::cout, item1) << std::endl;
  Sales_data item2("0-201-78345-X");
  print(std::cout, item2) << std::endl;
  Sales_data item3("0-201-78345-X", 3, 20.00);
  print(std::cout, item3) << std::endl;
  Sales_data item4(std::cin);
  print(std::cout, item4) << std::endl;
  return 0;
}
   #+END_SRC

** Exercise 7.12
   #+BEGIN_QUOTE
   Move the definition of the ~Sales_data~ constructor that takes an ~istream~
   into the body of the ~Sales_data~ class.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
#include <string>

struct Sales_data;
std::istream& read(std::istream &is, Sales_data &item);

struct Sales_data {
  // constructors added
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &is) { read(is, *this); }

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

int main()
{
  Sales_data item1;
  print(std::cout, item1) << std::endl;
  Sales_data item2("0-201-78345-X");
  print(std::cout, item2) << std::endl;
  Sales_data item3("0-201-78345-X", 3, 20.00);
  print(std::cout, item3) << std::endl;
  Sales_data item4(std::cin);
  print(std::cout, item4) << std::endl;
  return 0;
}   
   #+END_SRC

** Exercise 7.13
   #+BEGIN_QUOTE
   Rewrite the program from page 255 to use the ~istream~ constructor.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
#include <string>

struct Sales_data;
std::istream& read(std::istream &is, Sales_data &item);

struct Sales_data {
  // constructors added
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &is) { read(is, *this); }

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

int main()
{
  Sales_data total(std::cin); // variable to hold data for the next transaction

  // read the first transaction and ensure that there are data to process
  if (!total.isbn().empty()) {
    Sales_data trans;           // variable to hold the running sum
    // read and process the remaining transtraction
    while (read(std::cin, trans)) {
      // if we're still processing the same book
      if (total.bookNo == trans.bookNo) {
        // update the running total
        total.units_sold += trans.units_sold;
        total.revenue += trans.revenue;
      } else {
        // print results for the previous book
        print(std::cout, total) << std::endl;
        total = trans;          // total now refers to the next book
      }
    }
    print(std::cout, total) << std::endl;
  } else {
    // no input! warn the user
    std::cerr << "No data?!" << std::endl;
    return -1;                  // indicate failure
  }

  return 0;
}   
   #+END_SRC

** Exercise 7.14
   #+BEGIN_QUOTE
   Write a version of the default constructor that explicitly initializes the
   members to the values we have provided as in-class initializers.
   #+END_QUOTE

   #+BEGIN_SRC C++
Sales_data(): units_sold(0), revenue(0.0) { }    
   #+END_SRC

** Exercise 7.15
   #+BEGIN_QUOTE
   Add appropriate constructors to your ~Person~ class.
   #+END_QUOTE

   #+BEGIN_SRC C++
Person() = default;
Person(const std::string sname, const std::string saddr): name(sname), address(saddr) { }
Person(std::istream &is) { read(is, *this); }   
   #+END_SRC

* Exercises Section 7.2
** Exercise 7.16
   #+BEGIN_QUOTE
   What, if any, are the constraints on where and how often an access specifier
   may appear inside a class definition? What kinds of members should be defined
   after a ~public~ specifier? What kinds should be ~private~?
   #+END_QUOTE

   A class may contain zero or more access specifiers, and there are no
   restrictions on how often an access specifier may appear. Each access
   specifier specifies the access level of the succeeding members. The specified
   access level remains in effect until the next access specifier or the end of
   the class body.

   + Members defined after a ~public~ specifier are accessible to all parts of
     the program. The ~public~ members define the interface to the class.

   + Members defined after a ~private~ specifier are accessible to the member
     functions of the class but are not accessible to code that uses the class.
     The ~private~ sections encapsulate (i.e., hide) the implementation.

** Exercise 7.17
   #+BEGIN_QUOTE
   What, if any, are the differences between using ~class~ or ~struct~?
   #+END_QUOTE

   A class may define members before the first access specifier. Access to such
   members depends on how the class is defined. If we use the ~struct~ keyword,
   the members defined before the first access specifier are ~public~; if we use
   ~class~, then the members are ~private~.

** Exercise 7.18
   #+BEGIN_QUOTE
   What is encapsulation? Why is it useful?
   #+END_QUOTE
   Encapsulation: Separation of implementation from interface; encapsulation
   hides the implementation details of a type. In C++, encapsulation is enforced
   by putting the implementation in the private part of a class.

   Encapsulation provides two important advantages:
   + User code cannot inadvertently corrupt the state of an encapsulated object.
   + The implementation of an encapsulated class can change over time without
     requiring changes in user-level code.
   
** Exercise 7.19
   #+BEGIN_QUOTE
    Indicate which members of your ~Person~ class you would declare as ~public~
    and which you would declare as ~private~. Explain your choice.
   #+END_QUOTE

   The interface to the ~Person~ class should be defined as ~public~, like the
   constructors, ~get_name()~ and ~get_addr()~; the implementation of the
   ~Person~ class should be hided in ~private~ section, like ~name~ and
   ~address~.

* Exercises Section 7.2.1
** Exercise 7.20
   #+BEGIN_QUOTE
   When are friends useful? Discuss the pros and cons of using friends.
   #+END_QUOTE
   
   ~friend~ is a mechanism by which a class grants access to its non~public~
   members. Friends have the same access rights as members. Both classes and
   functions may be named as friends.
   
   *Pros*:
   + Some useful functions can refer to class members in the class scope without
     needing to explicitly prefix them with the class name;
   + you can access all the nonpublic members conveniently;
   + sometimes, more readable to the users of class.

   *Cons*:
   + lessens encapsulation and therefore maintainability;
   + code verbosity, declarations inside the class, outside the class.

** Exercise 7.21
   #+BEGIN_QUOTE
   Update your ~Sales_data~ class to hide its implementation. The programs
   you've written to use ~Sales_data~ operations should still continue to work.
   Recompile those programs with your new class definition to verify that they
   still work.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
#include <string>

struct Sales_data;
std::istream& read(std::istream &is, Sales_data &item);

struct Sales_data {
  // friend declarations for nonmember Sales_data operations added
  friend Sales_data add(const Sales_data &lhs, const Sales_data &rhs);
  friend std::istream& read(std::istream &is, Sales_data &item);
  friend std::ostream& print(std::ostream &os, const Sales_data &item);

  // other members and access specifiers as before
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &is) { read(is, *this); }

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

private:
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};


// definitions for nonmember parts of the Sales_data interface
Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

int main()
{
  Sales_data total(std::cin); // variable to hold data for the next transaction

  // read the first transaction and ensure that there are data to process
  if (!total.isbn().empty()) {
    Sales_data trans;           // variable to hold the running sum
    // read and process the remaining transtraction
    while (read(std::cin, trans)) {
      // if we're still processing the same book
      if (total.isbn() == trans.isbn()) {
        // update the running total
        total.combine(trans);
      } else {
        // print results for the previous book
        print(std::cout, total) << std::endl;
        total = trans;          // total now refers to the next book
      }
    }
    print(std::cout, total) << std::endl;
  } else {
    // no input! warn the user
    std::cerr << "No data?!" << std::endl;
    return -1;                  // indicate failure
  }

  return 0;
}   
   #+END_SRC

** Exercise 7.22
   #+BEGIN_QUOTE
   Update your ~Person~ class to hide its implementation.
   #+END_QUOTE

   #+BEGIN_SRC C++
class Person {
  friend std::istream& read(std::istream &is, Person &person);
  friend std::ostream& print(std::ostream &os, Person &person);

public:
  Person() = default;
  Person(const std::string sname, const std::string saddr): name(sname), address(saddr) { }
  Person(std::istream &is) { read(is, *this); }
   
  std::string get_name() const { return name; }
  std::string get_addr() const { return address; }

private:
  std::string name;
  std::string address;
};

std::istream&
read(std::istream &is, Person &person) {
  is >> person.name >> person.address;
  return is;
}

std::ostream&
print(std::ostream &os, Person &person) {
  os << person.name << " "
     << person.address << " " 
     << std::endl;
}   
   #+END_SRC

* Exercises Section 7.3.1
** Exercise 7.23
   #+BEGIN_QUOTE
   Write your own version of the ~Screen~ class.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
class Screen {
public: 
  typedef std::string::size_type pos;
private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
};   
   #+END_SRC

** Exercise 7.24
   #+BEGIN_QUOTE
   Give your ~Screen~ class three constructors: a default constructor; a
   constructor that takes values for height and width and initializes the
   contents to hold the given number of blanks; and a constructor that takes
   values for height, width, and a character to use as the contents of the
   screen.
   #+END_QUOTE

   #+BEGIN_SRC C++
class Screen {
public: 
  typedef std::string::size_type pos;
  Screen() = default;
  Screen(pos ht, pos wd): height(ht), width(wd), contents(ht * wd, ' ') { }
  Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht * wd, c) { }
private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
};   
   #+END_SRC

** Exercise 7.25
   #+BEGIN_QUOTE
   Can ~Screen~ safely rely on the default versions of copy and assignment? If
   so, why? If not, why not?
   #+END_QUOTE
   
   Yes. The synthesized versions are unlikely to work correctly for classes that
   allocate resources that reside outside the class objects
   themselves. Moreover, the synthesized versions for copy, assignment, and
   destruction work correctly for classes that have ~vector~ or ~string~
   members.

** Exercise 7.26
   #+BEGIN_QUOTE
   Define ~Sales_data::avg_price~ as an ~inline~ function.
   #+END_QUOTE

   Simply specify ~inline~ on the definition of ~Sales_data::avg_price~ outside
   of the class.

* Exercises Section 7.3.2
** Exercise 7.27
   #+BEGIN_QUOTE
   Add the ~move~, ~set~, and ~display~ operations to your version of
   ~Screen~. Test your class by executing the following code:
   #+END_QUOTE
   #+BEGIN_SRC C++
Screen myScreen(5, 5, 'X');
myScreen.move(4,0).set('#').display(cout);
cout << "\n";
myScreen.display(cout);
cout << "\n";
   #+END_SRC
   
   #+BEGIN_SRC C++
#include <iostream>
#include <string>

using std::cout;

class Screen {
public: 
  typedef std::string::size_type pos;
  Screen() = default;
  Screen(pos ht, pos wd): height(ht), width(wd), contents(ht * wd, ' ') { }
  Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht * wd, c) { }

  Screen &move(pos r, pos c);
  Screen &set(char c);
  Screen &set(pos r, pos col, char ch);

  // display overloaded on whether the object is const or not
  Screen &display(std::ostream &os) { do_display(os); return *this; }
  const Screen &display(std::ostream &os) const { do_display(os); return *this; }

private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;

  // function to do the work of displaying a Screen 
  void do_display(std::ostream &os) const { os << contents; }
};   

inline Screen &Screen::move(pos r, pos c)
{
  pos row = r * width;		// compute row location
  cursor = row + c;		// movew cursor to the column within that row
  return *this;			// return this object as an lvalue
}

inline Screen &Screen::set(char c)
{
  contents[cursor] = c;		// set the new value at the current cursor location
  return *this;
}

inline Screen &Screen::set(pos r, pos col, char c)
{
  contents[r*width + col] = c;	// set specified location to given value
  return *this;			// return this object as an lvalue
}

int main() 
{
  Screen myScreen(5, 5, 'X');
  myScreen.move(4,0).set('#').display(cout);
  cout << "\n";
  myScreen.display(cout);
  cout << "\n";
 
  return 0;
}   
   #+END_SRC

** Exercise 7.28
   #+BEGIN_QUOTE
   What would happen in the previous exercise if the return type of ~move~,
   ~set~, and ~display~ was ~Screen~ rather than ~Screen&~?
   #+END_QUOTE
   
   The call to ~set~ would only change the temporary copy, not ~myScreen~, so
   that first and second line of the output are different.

** Exercise 7.29
   #+BEGIN_QUOTE
   Revise your ~Screen~ class so that ~move~, ~set~, and ~display~ functions
   return ~Screen~ and check your prediction from the previous exercise.
   #+END_QUOTE
   
   Output for ex07_27.cc:
   #+BEGIN_SRC 
XXXXXXXXXXXXXXXXXXXX#XXXX
XXXXXXXXXXXXXXXXXXXX#XXXX   
   #+END_SRC

   Output for ex07_29.cc:
   #+BEGIN_SRC 
XXXXXXXXXXXXXXXXXXXX#XXXX
XXXXXXXXXXXXXXXXXXXXXXXXX   
   #+END_SRC

** Exercise 7.30
   #+BEGIN_QUOTE
   It is legal but redundant to refer to members through the ~this~
   pointer. Discuss the pros and cons of explicitly using the ~this~ pointer to
   access members.
   #+END_QUOTE

* Exercises Section 7.3.3
** Exercise 7.31
   #+BEGIN_QUOTE
   Define a pair of classes ~X~ and ~Y~, in which ~X~ has a pointer to ~Y~, and
   ~Y~ has an object of type ~X~.
   #+END_QUOTE

   #+BEGIN_SRC C++
class Y;  // forward declaration
class X {
  Y *py;
};   
class Y {
  X x;
};
   #+END_SRC

* Exercises Section 7.3.4
** Exercise 7.32
   #+BEGIN_QUOTE
   Define your own versions of ~Screen~ and ~Window_mgr~ in which ~clear~ is a
   member of ~Window_mgr~ and a ~friend~ of ~Screen~.
   #+END_QUOTE

   #+BEGIN_SRC C++
class Window_mgr {
public:
  // location ID for each screen on the window
  using ScreenIndex = std::vector<Screen>::size_type;
  // reset the Screen at the given position to all blanks
  void clear(ScreenIndex);
private:
  std::vector<Screen> screens{Screen(24, 80, ' ')};
};
// Screen must be declaired before clear can use members of Screen
class Screen {
  // Window_mgr::clear must have been declared before class Screen
  friend void Window_mgr::clear(ScreenIndex);
  // ... rest of the Screen class
};
void Window_mgr::clear(ScreenIndex i)
{
  // s is a reference to the Screen we want to clear
  Screen &s = screens[i];
  // reset the contents of that Screen to all blanks
  s.contents = string(s.height * s.width, ' ');
}
   #+END_SRC

* Exercises Section 7.4
** Exercise 7.33
   #+BEGIN_QUOTE
   What would happen if we gave Screen a size member defined as follows? Fix any
   problems you identify.
   #+END_QUOTE
   #+BEGIN_SRC C++
pos Screen::size() const
{
  return height * width;
}
   #+END_SRC
  
   Because the return type appears before the name of the class is seen, it
   appears outside the scope of class ~Screen~. To use ~pos~ for the return
   type, we must specify the class in which that type is defined.

* Exercises Section 7.4.1
** Exercise 7.34
   #+BEGIN_QUOTE
   What would happen if we put the typedef of pos in the Screen class on page
   285 as the last line in the class?
   #+END_QUOTE
   
   There is an error in
   #+BEGIN_SRC
dummy_fcn(pos height)
           ^
Unknown type name 'pos'   
   #+END_SRC
   
   Definitions of type names usually should appear at the beginning of a
   class. That way any member that uses that type will be seen after the type
   name has already been defined.

** Exercise 7.35
   #+BEGIN_QUOTE
   Explain the following code, indicating which definition of Type or initVal
   is used for each use of those names. Say how you would fix any errors.
   #+END_QUOTE
   #+BEGIN_SRC C++
typedef string Type;
Type initVal();
class Exercise {
public:
  typedef double Type;
  Type setVal(Type);
  Type initVal();
private:
  int val;
};
Type Exercise::setVal(Type parm) {
  val = parm + initVal();
  return val;
}   
   #+END_SRC

   The code with some comments:
   #+BEGIN_SRC C++
typedef string Type;
Type initVal();  // string
class Exercise {
public:
  typedef double Type;
  Type setVal(Type);  // double
  Type initVal();     // double
private:
  int val;
};
Type Exercise::setVal(Type parm) {  // string; double 
  val = parm + initVal();  // Exercise::initVal()
  return val;
}   
   #+END_SRC
   
   ~Type Exercise::setVal(Type parm)~ should be changed as ~Exercise::Type
   Exercise::setVal(Type parm)~. Because the return type appears before the
   name of the class is seen, it appears outside the scope of class
   ~Exercise~. To use ~Exercise::Type~ for the return type, we must specify
   the class in which that type is defined.

* Exercises Section 7.5.1 
** Exercise 7.36
   #+BEGIN_QUOTE
   The following initializer is in error. Identify and fix the problem.
   #+END_QUOTE
   #+BEGIN_SRC C++
struct X {
  X (int i, int j): base(i), rem(base % j) { }
  int rem, base;
}; 
   #+END_SRC

   fixed:
   #+BEGIN_SRC C++
struct X {
  X (int i, int j): rem(i % j), base(i) { }
  int rem, base;
};    
   #+END_SRC

   It is a good idea to write constructor initializers in the same order as the
   members are declared. Moreover, when possible, avoid using members to
   initialize other members.
 
** Exercise 7.37
   #+BEGIN_QUOTE
   Using the version of ~Sales_data~ from this section, determine which
   constructor is used to initialize each of the following variables and list
   the values of the data members in each object:
   #+END_QUOTE
   #+BEGIN_SRC C++
Sales_data first_item(cin);
 
int main() {
  Sales_data next;
  Sales_data last("9-999-99999-9");
}   
   #+END_SRC

   The code with some comments:
   #+BEGIN_SRC C++
Sales_data first_item(cin);  // Sales_data(std::istream &is)
                             // The values are up to the input.
 
int main() {
  Sales_data next;  // Sales_data(std::string s = "")
                    // bookNo = "", units_sold = 0, revenue = 0.
  Sales_data last("9-999-99999-9");  // Sales_data(std::string s = "")
                    // bookNo = "9-999-99999-9", units_sold = 0, revenue = 0.
}   
   #+END_SRC
 
** Exercise 7.38
   #+BEGIN_QUOTE
   We might want to supply ~cin~ as a default argument to the constructor that
   takes an ~istream&~. Write the constructor declaration that uses ~cin~ as a
   default argument.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
Sales_data(std::istream &is = std::cin) { read(is, *this); }   
   #+END_SRC

** Exercise 7.39
   #+BEGIN_QUOTE
   Would it be legal for both the constructor that takes a ~string~ and the one
   that takes an ~istream&~ to have default arguments? If not, why not?
   #+END_QUOTE
   
   No, because the call of overloaded 'Sales_data()' is ambiguous.

** Exercise 7.40
   #+BEGIN_QUOTE
   Choose one of the following abstractions (or an abstraction of your own
   choosing). Determine what data are needed in the class. Provide an
   appropriate set of constructors. Explain your decisions.
   + (a) ~Book~
   + (b) ~Date~
   + (c) ~Employee~
   + (d) ~Vehicle~
   + (e) ~Object~
   + (f) ~Tree~
   #+END_QUOTE

   #+BEGIN_SRC C++
class Book 
{
public:
  Book(std::string isbn, std::string const& name, std::string const& author)
    :isbn_(isbn), name_(name), author_(author)
  { }

  explicit Book(std::istream &is) 
  { 
    is >> isbn_ >> name_ >> author_;
  }

private:
  std::string isbn_;
  std::string name_;
  std::string author_;
};   
   #+END_SRC

* Exercises Section 7.6
** Exercise 7.56
   #+BEGIN_QUOTE
   What is a static class member? What are the advantages of static members?
   How do they differ from ordinary members?
   #+END_QUOTE
   
   Classes sometimes need members that are associated with the class, rather
   than with individual objects of the class type. For example, a bank account
   class might need a data member to represent the current prime interest
   rate. In this case, we'd want to associate the rate with the class, not
   with each individual object. From an efficiency standpoint, there'd be no
   reason for each object to store the rate. Much more importantly, if the
   rate changes, we'd want each object to use the new value.
    
   The static members of a class exist outside any object. Objects do not
   contain data associated with static data members. Similarly, static member
   functions are not bound to any object; they do not have a this pointer.

** Exercise 7.57
   #+BEGIN_QUOTE
   Write your own version of the ~Account~ class.
   #+END_QUOTE

** Exercise 7.58
   #+BEGIN_QUOTE
   Which, if any, of the following static data member declarations and
   definitions are errors? Explain why.
   #+END_QUOTE
   #+BEGIN_SRC C++
// example.h
class Example {
public:
static double rate = 6.5;
static const int vecSize = 20;
static vector<double> vec(vecSize);
};
// example.C
#include "example.h"
double Example::rate;
vector<double> Example::vec;   
   #+END_SRC
   
   Fixed:
   #+BEGIN_SRC C++
// example.h
class Example {
public:
  static constexpr double rate = 6.5;
  static const int vecSize = 20;
  static vector<double> vec;
};
// example.C
#include "example.h"
constexpr double Example::rate;
vector<double> Example::vec(Example::vecSize);   
   #+END_SRC
   Ordinarily, class static members may not be initialized in the class
   body. However, we can provide in-class initializers for static members that
   have const integral type and must do so for static members that are
   constexprs of literal type. The initializers must be constant
   expressions.
