* Exercises Section 7.1.1
** Exercise 7.1
   #+BEGIN_QUOTE
   Write a version of the transaction-processing program from § 1.6 (p. 24)
   using the ~Sales_data~ class you defined for the exercises in § 2.6.1 (p.
   72).
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>

struct Sales_data {
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

int main()
{
  Sales_data total; // variable to hold data for the next transaction

  // read the first transaction and ensure that there are data to process
  if (std::cin >> total.bookNo >> total.units_sold >> total.revenue) {
    Sales_data trans;           // variable to hold the running sum
    // read and process the remaining transtraction
    while (std::cin >> trans.bookNo >> trans.units_sold >> trans.revenue) {
      // if we're still processing the same book
      if (total.bookNo == trans.bookNo) {
        // update the running total
        total.units_sold += trans.units_sold;
        total.revenue += trans.revenue;
      } else {
        // print results for the previous book
        std::cout << total.bookNo << " "
                  << total.units_sold << " "
                  << total.revenue << std::endl;
        total = trans;          // total now refers to the next book
      }
    }
    std::cout << total.bookNo << " "
              << total.units_sold << " "
              << total.revenue << std::endl;
  } else {
    // no input! warn the user
    std::cerr << "No data?!" << std::endl;
    return -1;                  // indicate failure
  }

  return 0;
}
   #+END_SRC
   
* Exercises Section 7.1.2
** Exercise 7.2
   #+BEGIN_QUOTE
   Add the ~combine~ and ~isbn~ members to the ~Sales_data~ class you wrote for
   the exercises in § 2.6.2 (p. 76).
   #+END_QUOTE

   #+BEGIN_SRC C++
// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was called
}

std::string 
Sales_data::isbn() const { 
  return bookNo; 
}   
   #+END_SRC

** Exercise 7.3
   #+BEGIN_QUOTE
   Revise your transaction-processing program from § 7.1.1 (p. 256) to use these
   members.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>

struct Sales_data {
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;

  // operations on Sales_data objects
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
};

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was called
}

int main()
{
  Sales_data total; // variable to hold data for the next transaction

  // read the first transaction and ensure that there are data to process
  if (std::cin >> total.bookNo >> total.units_sold >> total.revenue) {
    Sales_data trans;           // variable to hold the running sum
    // read and process the remaining transtraction
    while (std::cin >> trans.bookNo >> trans.units_sold >> trans.revenue) {
      // if we're still processing the same book
      if (total.isbn() == trans.isbn()) {
        // update the running total
        total.combine(trans);
      }
      else {
        // print results for the previous book
        std::cout << total.bookNo << " "
                  << total.units_sold << " "
                  << total.revenue << std::endl;
        total = trans;          // total now refers to the next book
      }
    }
    std::cout << total.bookNo << " "
              << total.units_sold << " "
              << total.revenue << std::endl;
  } else {
    // no input! warn the user
    std::cerr << "No data?!" << std::endl;
    return -1;                  // indicate failure
  }

  return 0;
}
   #+END_SRC

** Exercise 7.4
   #+BEGIN_QUOTE
   Write a class named ~Person~ that represents the name and address of a
   person. Use a ~string~ to hold each of these elements. Subsequent exercises
   will incrementally add features to this class.
   #+END_QUOTE

   #+BEGIN_SRC C++
class Person {
 private:
  std::string name;
  std::string address;
};   
   #+END_SRC

** Exercise 7.5
   #+BEGIN_QUOTE
   Provide operations in your ~Person~ class to return the name and address.
   Should these functions be ~const~? Explain your choice.
   #+END_QUOTE

   #+BEGIN_SRC C++
class Person {
 private:
  std::string name;
  std::string address;
 public:
  std::string get_name() const { return name; }
  std::string get_addr() const { return address; }
};   
   #+END_SRC

   The body of ~get_name~ and ~get_addr~ will not change the object to which
   ~this~ points, so these functions should be ~const~.

* Exercises Section 7.1.3
** Exercise 7.6
   #+BEGIN_QUOTE
   Define your own versions of the ~add~, ~read~, and ~print~ functions.
   #+END_QUOTE

   #+BEGIN_SRC C++
Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}
   #+END_SRC
 
** Exercise 7.7
   #+BEGIN_QUOTE
   Rewrite the transaction-processing program you wrote for the exercises in §
   7.1.2 (p. 260) to use these new functions.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>

struct Sales_data {
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;

  // operations on Sales_data objects
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;
};

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
				// called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}   

int main()
{
  Sales_data total; // variable to hold data for the next transaction

  // read the first transaction and ensure that there are data to process
  if (read(std::cin, total)) {
    Sales_data trans;           // variable to hold the running sum
    // read and process the remaining transtraction
    while (read(std::cin, trans)) {
      // if we're still processing the same book
      if (total.isbn() == trans.isbn()) {
	      // update the running total
	      total.combine(trans);	
      }
      else {
        // print results for the previous book
	      print(std::cout, total);
        std::cout << std::endl;
        total = trans;          // total now refers to the next book
      }
    }
    print(std::cout, total);
    std::cout << std::endl;
  } else {
    // no input! warn the user
    std::cerr << "No data?!" << std::endl;
    return -1;                  // indicate failure
  }

  return 0;
}   
  
 #+END_SRC

** Exercise 7.8
   #+BEGIN_QUOTE
   Why does ~read~ define its ~Sales_data~ parameter as a plain reference and
   ~print~ define its parameter as a reference to ~const~?
   #+END_QUOTE
   
   ~Sales_data~ is defined as a plain reference in ~read~ since we may change
   its data members while it is defined as a reference to ~const~ in ~print~
   since we don't want to write to its data members.

** Exercise 7.9
   #+BEGIN_QUOTE
   Add operations to read and print ~Person~ objects to the code you wrote for
   the exercises in § 7.1.2 (p. 260).
   #+END_QUOTE

   #+BEGIN_SRC C++
std::istream&
read(std::istream &is, Person &person) {
  is >> person.name >> person.address;
  return is;
}

std::ostream&
print(std::ostream &os, Person &person) {
  os << person.name << " "
     << person.address << " " 
     << std::endl;
}   
   #+END_SRC

** Exercise 7.10
   #+BEGIN_QUOTE
   What does the condition in the following ~if~ statement do?

   ~if (read(read(cin, data1), data2))~
   #+END_QUOTE

   The condition of the ~if~ would check if it is successful to read two
   Sales_data objects.

* Exercises Section 7.1.4
** Exercise 7.11
   #+BEGIN_QUOTE
   Add constructors to your ~Sales_data~ class and write a program to use each
   of the constructors.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
#include <string>

struct Sales_data {
  // constructors added
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &);

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

Sales_data::Sales_data(std::istream &is)
{
  read(is, *this);
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

int main()
{
  Sales_data item1;
  print(std::cout, item1) << std::endl;
  Sales_data item2("0-201-78345-X");
  print(std::cout, item2) << std::endl;
  Sales_data item3("0-201-78345-X", 3, 20.00);
  print(std::cout, item3) << std::endl;
  Sales_data item4(std::cin);
  print(std::cout, item4) << std::endl;
  return 0;
}
   #+END_SRC

** Exercise 7.12
   #+BEGIN_QUOTE
   Move the definition of the ~Sales_data~ constructor that takes an ~istream~
   into the body of the ~Sales_data~ class.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
#include <string>

struct Sales_data;
std::istream& read(std::istream &is, Sales_data &item);

struct Sales_data {
  // constructors added
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &is) { read(is, *this); }

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

int main()
{
  Sales_data item1;
  print(std::cout, item1) << std::endl;
  Sales_data item2("0-201-78345-X");
  print(std::cout, item2) << std::endl;
  Sales_data item3("0-201-78345-X", 3, 20.00);
  print(std::cout, item3) << std::endl;
  Sales_data item4(std::cin);
  print(std::cout, item4) << std::endl;
  return 0;
}   
   #+END_SRC

** Exercise 7.13
   #+BEGIN_QUOTE
   Rewrite the program from page 255 to use the ~istream~ constructor.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
#include <iostream>
#include <string>

struct Sales_data;
std::istream& read(std::istream &is, Sales_data &item);

struct Sales_data {
  // constructors added
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) { }
  Sales_data(const std::string &s, unsigned n, double p):
    bookNo(s), units_sold(n), revenue(p*n) { }
  Sales_data(std::istream &is) { read(is, *this); }

  // other members as before
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;

  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

Sales_data
add(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;		// copy data members from lhs into sum
  sum.combine(rhs);		// add data members from rhs into sum
  return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
std::istream&
read(std::istream &is, Sales_data &item) {
  double price = 0.0;
  is >> item.bookNo >> item.units_sold >> price;
  item.revenue = price * item.units_sold;
  return is;
}

std::ostream&
print(std::ostream &os, const Sales_data &item) {
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs) {
  units_sold += rhs.units_sold;	// add the members of rhs into
  revenue += rhs.revenue;	// the members of "this" object
  return *this;			// return the object on which the function was
  // called
}

double Sales_data::avg_price() const {
  if (units_sold)
    return revenue/units_sold;
  else
    return 0;
}

int main()
{
  Sales_data total(std::cin); // variable to hold data for the next transaction

  // read the first transaction and ensure that there are data to process
  if (!total.isbn().empty()) {
    Sales_data trans;           // variable to hold the running sum
    // read and process the remaining transtraction
    while (read(std::cin, trans)) {
      // if we're still processing the same book
      if (total.bookNo == trans.bookNo) {
        // update the running total
        total.units_sold += trans.units_sold;
        total.revenue += trans.revenue;
      } else {
        // print results for the previous book
        print(std::cout, total) << std::endl;
        total = trans;          // total now refers to the next book
      }
    }
    print(std::cout, total) << std::endl;
  } else {
    // no input! warn the user
    std::cerr << "No data?!" << std::endl;
    return -1;                  // indicate failure
  }

  return 0;
}   
   #+END_SRC

** Exercise 7.14
   #+BEGIN_QUOTE
   Write a version of the default constructor that explicitly initializes the
   members to the values we have provided as in-class initializers.
   #+END_QUOTE

   #+BEGIN_SRC C++
Sales_data(): units_sold(0), revenue(0.0) { }    
   #+END_SRC

** Exercise 7.15
   #+BEGIN_QUOTE
   Add appropriate constructors to your ~Person~ class.
   #+END_QUOTE

   #+BEGIN_SRC C++
Person() = default;
Person(const std::string sname, const std::string saddr): name(sname), address(saddr) { }
Person(std::istream &is) { read(is, *this); }   
   #+END_SRC

* Exercises Section 7.2
** Exercise 7.16
   #+BEGIN_QUOTE
   What, if any, are the constraints on where and how often an access specifier
   may appear inside a class definition? What kinds of members should be defined
   after a ~public~ specifier? What kinds should be ~private~?
   #+END_QUOTE

   A class may contain zero or more access specifiers, and there are no
   restrictions on how often an access specifier may appear. Each access
   specifier specifies the access level of the succeeding members. The specified
   access level remains in effect until the next access specifier or the end of
   the class body.

   + Members defined after a ~public~ specifier are accessible to all parts of
     the program. The ~public~ members define the interface to the class.

   + Members defined after a ~private~ specifier are accessible to the member
     functions of the class but are not accessible to code that uses the class.
     The ~private~ sections encapsulate (i.e., hide) the implementation.

** Exercise 7.17
   #+BEGIN_QUOTE
   What, if any, are the differences between using ~class~ or ~struct~?
   #+END_QUOTE

   A class may define members before the first access specifier. Access to such
   members depends on how the class is defined. If we use the ~struct~ keyword,
   the members defined before the first access specifier are ~public~; if we use
   ~class~, then the members are ~private~.

** Exercise 7.18
   #+BEGIN_QUOTE
   What is encapsulation? Why is it useful?
   #+END_QUOTE

* Exercises Section 7.3.3
** Exercise 7.31
   #+BEGIN_QUOTE
   Define a pair of classes ~X~ and ~Y~, in which ~X~ has a pointer to ~Y~, and
   ~Y~ has an object of type ~X~.
   #+END_QUOTE

   #+BEGIN_SRC C++
class Y;  // forward declaration
class X {
  Y *py;
};   
class Y {
  X x;
};
   #+END_SRC

