* Exercises Section 15.2.1
** Exercise 15.1

#+BEGIN_QUOTE
What is a virtual member?
#+END_QUOTE
  
The base class defines as ~virtual~ those functions it expects its derived
classes to override.
 
** Exercise 15.2 

#+BEGIN_QUOTE
How does the ~protected~ access specifier differ from ~private~?
#+END_QUOTE

Like any other code that uses the base class, a derived class may access the
~public~ members of its base class but may not access the ~private~ members.
However, sometimes a base class has members that it wants to let its derived
classes use while still prohibiting access to those same members by other users.
We specify such members after a ~protected~ access specifier.

** Exercise 15.3

#+BEGIN_QUOTE
Define your own versions of the ~Quote~ class and the ~print_total~ function.
#+END_QUOTE

Quote.h:
#+BEGIN_SRC C++
#ifndef QUOTE_H
#define QUOTE_H

#include <iostream>
#include <string>

class Quote {
  public:
    Quote() = default;            // = default see 7.1.4 (p.264)
  Quote(const std::string &book, double sales_price) :
    bookNo(book), price(sales_price) { }

    std::string isbn() const { return bookNo; }

    // returns the total sales price for the specified number of items
    // derived classes will override and apply different discount algorithms
    virtual double net_price(std::size_t n) const
    { return n * price; }

    virtual ~Quote() = default;   // dynamic binding for the destructor

  private:
    std::string bookNo;           // ISBN number of this item

  protected:
    double price = 0.0;           // normal, undiscounted price 
};

double print_total(std::ostream &os, const Quote &item, size_t n);

#endif
#+END_SRC

Quote.cc:
#+BEGIN_SRC C++
#include "Quote.h"

#include <iostream>
using std::ostream;
using std::endl;

// calculate and print the price for the give number if copies, applying any
// discount
double print_total(ostream &os, const Quote &item, size_t n)
{
  // depending on the type of the object bound to the item parameter
  // calls either Quote::net_price or Bulk_quote::net_price
  double ret = item.net_price(n);
  os << "ISBN: " << item.isbn() // calls Quote::isbn
     << " # sold@ "<< n << " total due: " << ret << endl;
  return ret;
}
#+END_SRC

ex15_03.cc:
#+BEGIN_SRC C++
#include <iostream>
using std::cout;

#include "Quote.h"

int main()
{
  Quote base("0-201-82470-1", 50);
  print_total(cout, base, 10);  // calls Quotes::net_price

  return 0;
}
#+END_SRC

** Exercise 15.4

#+BEGIN_QUOTE
Which of the following declarations, if any, are incorrect? Explain why.
#+END_QUOTE

#+BEGIN_SRC C++
class Base { ... };
(a) class Derived : public Derived { ... };
(b) class Derived : private Base { ... };
(c) class Derived : public Base;
#+END_SRC

+ (a) error: it is impossible to derive a class from itself
+ (b) error: it is a definition instead of a declaration
+ (c) error: derivation lists can's appear here

** Exercise 15.5

#+BEGIN_QUOTE
Define your own version of the ~Bulk_quote~ class
#+END_QUOTE

** Exercise 15.8

#+BEGIN_QUOTE
Define static type and dynamic type.
#+END_QUOTE

The *static* type of an expression is always known at compile time -- it is the
type with which a variable is declared or that an expression yields. The *dynamic*
type is the type of the object in memory that the variable or expression
represents. The dynamic type may not be known until run time.

** Exercise 15.9

#+BEGIN_QUOTE
When is it possible for an expressionâ€™s static type to differ from its dynamic
type? Give three examples in which the static and dynamic type differ.
#+END_QUOTE

