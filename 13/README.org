* Exercises Section 13.1.1
** Exercise 13.1 
   #+BEGIN_QUOTE
   What is a copy constructor? When is it used?
   #+END_QUOTE

   A constructor is the *copy constructor* if its first parameter is
   a *reference* to the class type and any additional parameters have *default
   values*.

   Copy initialization ordinarily uses the copy constructor (or the move
   constructor), and it happens when we
   + Define variables using an =;
   + Pass an object as an argument to a parameter of nonreference type;
   + Return an object from a function that has a nonreference return type;
   + Brace initialize the elements in an array or the members of an aggregate
     class;
   + Some class types also use copy initialization for the objects they
     allocate.

** Exercise 13.2
   #+BEGIN_QUOTE
   Explain why the following declaration is illegal:
   #+END_QUOTE

   #+BEGIN_SRC C++
   Sales_data::Sales_data(Sales_data rhs);
   #+END_SRC

   The fact that the copy constructor is used to initialize nonreference
   parameters of class type explains why the copy constructor’s own parameter
   must be a reference. If that parameter were not a reference (like the
   declaration in this question), then the call would never succeed -- to call
   the copy constructor, we’d need to use the copy constructor to copy the
   argument, but to copy the argument, we’d need to call the copy constructor,
   and so on indefinitely.

** Exercise 13.3
   #+BEGIN_QUOTE
   What happens when we copy a ~StrBlob~? What about ~StrBlobPtr~ s?
   #+END_QUOTE
    
   The type of each member determines how that member is copied: Members of
   class type are copied by the copy constructor for that class; members of
   built-in type are copied directly. Although we cannot directly copy an array
   (§ 3.5.1, p. 114), the synthesized copy constructor copies members of array
   type by copying each element.  Elements of class type are copied by using the
   elements’ copy constructor.
 
** Exercise 13.4
   #+BEGIN_QUOTE
   Assuming ~Point~ is a class type with a public copy constructor, identify each
   use of the copy constructor in this program fragment:
   #+END_QUOTE
   #+BEGIN_SRC C++
Point global;
Point foo_bar(Point arg) // Pass an object as an argument to a parameter of nonreference type
{
  Point local = arg, *heap = new Point(global); // Define variables using an =.
  *heap = local;
  Point pa[ 4 ] = { local, *heap }; // Brace initialize the elements in an array
  return *heap; // Return an object from a function that has a nonreference return type
}   
   #+END_SRC
 
** Exercise 13.5
   #+BEGIN_QUOTE
   Given the following sketch of a class, write a copy constructor that copies
   all the members. Your constructor should dynamically allocate a new string (§
   12.1.2, p. 458) and copy the object to which ps points, rather than copying
   ps itself.
   #+END_QUOTE
   #+BEGIN_SRC C++
class HasPtr {
 public:
  HasPtr(const std::string &s = std::string()):
  ps(new std::string(s)), i(0) { }
 private:
  std::string *ps;
  int i;
};   
   #+END_SRC

   #+BEGIN_SRC C++
HasPtr::HasPtr(const HasPtr &orig): 
  ps(new std::string(*orig.ps)), i(orig.i) { }   
   #+END_SRC

* Exercises Section 13.1.2
** Exercise 13.6
   #+BEGIN_QUOTE
   What is a copy-assignment operator? When is this operator used? What does the
   synthesized copy-assignment operator do? When is it synthesized?
   #+END_QUOTE

   copy-assignment operator: Version of the assignment operator that takes an
   object of the same type as its type. Ordinarily, the copy-assignment operator
   has a parameter that is a reference to const and returns a reference to its
   object. The compiler synthesizes the copy-assignment operator if the class
   does not explicitly provide one.

** Exercise 13.7
   #+BEGIN_QUOTE
   What happens when we assign one ~StrBlob~ to another?  What about
   ~StrBlobPtrs~?
   #+END_QUOTE
    
   Just as it does for the copy constructor, the compiler generates a
   synthesized copy- assignment operator for a class if the class does not
   define its own. Analogously to the copy constructor, for some classes the
   synthesized copy-assignment operator disallows assignment (§ 13.1.6,
   p. 508). Otherwise, it assigns each nonstatic member of the right-hand object
   to the corresponding member of the left-hand object using the copy-assignment
   operator for the type of that member. Array members are assigned by assigning
   each element of the array. The synthesized copy-assignment operator returns a
   reference to its left-hand object.  As an example, the following is
   equivalent to the synthesized copy-
 
** Exercise 13.8
   #+BEGIN_QUOTE
   Write the assignment operator for the ~HasPtr~ class from exercise 13.5 in §
   13.1.1 (p. 499). As with the copy constructor, your assignment operator
   should copy the object to which ~ps~ points.
   #+END_QUOTE
 
   #+BEGIN_SRC C++
HasPtr&
HasPtr::operator=(const HasPtr &orig) {
  if(this != &orig) {
    std::string *ps_tmp = new std::string(*orig.ps);
    delete ps;
    ps = ps_tmp;
    i = orig.i;
  }
  return *this;
}   
   #+END_SRC

* Exercises Section 13.1.3
** Exercise 13.9
   #+BEGIN_QUOTE
   What is a destructor? What does the synthesized destructor do? When is a
   destructor synthesized?
   #+END_QUOTE

   The destructor operates inversely to the constructors: Constructors
   initialize the nonstatic data members of an object and may do other work;
   destructors do whatever work is needed to free the resources used by an
   object and destroy the nonstatic data members of the object.
    
   The compiler defines a synthesized destructor for any class that does not
   define its own destructor. As with the copy constructor and the
   copy-assignment operator, for some classes, the synthesized destructor is
   defined to disallow objects of the type from being destroyed (§ 13.1.6,
   p. 508). Otherwise, the synthesized destructor has an empty function body.

** Exercise 13.10
   #+BEGIN_QUOTE
   What happens when a ~StrBlob~ object is destroyed? What about a ~StrBlobPtr~?
   #+END_QUOTE
 
   When a ~StrBlob~ object is destroyed, the ~shared_ptr~ destructor will
   decrement the reference count of the object. It will be freed if the count go
   to zero.

   When a ~StrBlobPtr~ object is destroyed, the reference count will not be
   changed and object dynamically allocated will not be freed.

** Exercise 13.11
   #+BEGIN_QUOTE
   Add a destructor to your ~HasPtr~ class from the previous exercises.
   #+END_QUOTE

   #+BEGIN_SRC C++
HasPtr::~HasPtr() { delete ps; }   
   #+END_SRC

** Exercise 13.12
   #+BEGIN_QUOTE
   How many destructor calls occur in the following code fragment?
   #+END_QUOTE
   #+BEGIN_SRC C++
bool fcn(const Sales_data *trans, Sales_data accum)
{
  Sales_data item1(*trans), item2(accum);
  return item1.isbn() != item2.isbn();
}   
   #+END_SRC

   Three destructor calls occur (item1, item2, accum). 

** Exercise 13.13
   #+BEGIN_QUOTE
   A good way to understand copy-control members and constructors is to define a
   simple class with these members in which each member prints its name:
   #+END_QUOTE
   #+BEGIN_SRC C++
struct X {
  X() { std::cout << "X()" << std::endl; }
  X(const X&) { std::cout << "X(const X&)" << std::endl; }
};   
   #+END_SRC    
   Add the copy-assignment operator and destructor to ~X~ and write a program
   using ~X~ objects in various ways: Pass them as nonreference and reference
   parameters; dynamically allocate them; put them in containers; and so
   forth. Study the output until you are certain you understand when and why
   each copy-control member is used. As you read the output, remember that the
   compiler can omit calls to the copy constructor.
 
   #+BEGIN_SRC C++
#include <iostream>
#include <vector>

struct X {
  X() { std::cout << "X()" << std::endl; }
  X(const X&) { std::cout << "X(const X&)" << std::endl; }
  X& operator=(const X&) { 
    std::cout << "X& operator=(const X&)" << std::endl;
    return *this;
  }
  ~X() { std::cout << "~X()" << std::endl; }
};
 
void f(X x, const X &rx) {
  std::cout << "inside f()" << std::endl;
  std::vector<X> vec;
  vec.push_back(x);
  vec.push_back(rx);
}

int main()
{
  X x1, x2 = x1, x3;
  x3 = x1;
  X *px = new X;
  std::cout << "before f()" << std::endl;
  f(*px, *px);
  std::cout << "after f()" << std::endl;
  delete px;

  return 0;
}   
   #+END_SRC

* Exercises Section 13.1.4
** Exercise 13.14
   #+BEGIN_QUOTE
   Assume that ~numbered~ is a class with a default constructor that generates a
   unique serial number for each object, which is stored in a data member named
   ~mysn~. Assuming ~numbered~ uses the synthesized copy- control members and
   given the following function:
   #+END_QUOTE
   #+BEGIN_SRC C++
void f (numbered s) { cout << s.mysn << endl; }   
   #+END_SRC
   #+BEGIN_QUOTE
   what output does the following code produce?
   #+END_QUOTE
   #+BEGIN_SRC C++
numbered a, b = a, c = b;
f(a); f(b); f(c);   
   #+END_SRC

   Three identical serial number.

** Exercise 13.15
   #+BEGIN_QUOTE
   Assume ~numbered~ has a copy constructor that generates a new serial
   number. Does that change the output of the calls in the previous exercise? If
   so, why? What output gets generated?
   #+END_QUOTE

   Yes, the output will be changed with three different serial number since the
   copy constructor will generate a new serial number when passing the object as
   the argument to the non-reference parameter.

** Exercise 13.16
   #+BEGIN_QUOTE
   What if the parameter in ~f~ were ~const numbered&~?  Does that change the
   output? If so, why? What output gets generated?
   #+END_QUOTE

   Yes, the output will be changed with three different serial number since the
   copy constructor will generate a new serial number when defining the
   variables using an =.

** Exercise 13.17
   #+BEGIN_QUOTE
   Write versions of ~numbered~ and ~f~ corresponding to the previous three
   exercises and check whether you correctly predicted the output.
   #+END_QUOTE

   ex13_17a.cc (Exercise 13.14):
   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

struct numbered {
  numbered() { mysn = unique_serial_number++; }
  int mysn;
  static int unique_serial_number;
};

int numbered::unique_serial_number = 10;

void f(numbered s) { cout << s.mysn << endl; }

int main ()
{
  numbered a, b = a, c = b;
  f(a); f(b); f(c);

  return 0;
}   
   #+END_SRC

   ex13_17b.cc (Exercise 13.15):
   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

struct numbered {
  numbered() { mysn = unique_serial_number++; }
  numbered(const numbered& s) { mysn = unique_serial_number++; }
  int mysn;
  static int unique_serial_number;
};

int numbered::unique_serial_number = 10;

void f(numbered s) { cout << s.mysn << endl; }

int main ()
{
  numbered a, b = a, c = b;
  f(a); f(b); f(c);

  return 0;
}   
   #+END_SRC

   ex13_17c.cc (Exercise 13.16):  
   #+BEGIN_SRC C++
#include <iostream>
using std::cout; using std::endl;

struct numbered {
  numbered() { mysn = unique_serial_number++; }
  numbered(const numbered& s) { mysn = unique_serial_number++; }
  int mysn;
  static int unique_serial_number;
};

int numbered::unique_serial_number = 10;

void f(const numbered &s) { cout << s.mysn << endl; }

int main ()
{
  numbered a, b = a, c = b;
  f(a); f(b); f(c);

  return 0;
}   
   #+END_SRC

* Exercises Section 13.1.6
** Exercise 13.18
   #+BEGIN_QUOTE
   Define an ~Employee~ class that contains an employee name and a unique
   employee identifier. Give the class a default constructor and a constructor
   that takes a ~string~ representing the employee’s name. Each constructor
   should generate a unique ID by incrementing a static data member.
   #+END_QUOTE

   #+BEGIN_SRC C++
struct Employee {
  Employee() { id_ = unique_identifier_; }
  Employee(const std::string &name): name_(name) {
    id_ = unique_identifier_;
  }

  int get_id() const { return id_; } 

 private:
  std::string name_;
  int id_;
  static int unique_identifier_;
};

int Employee::unique_identifier_ = 0;
   #+END_SRC

** Exercise 13.19
   #+BEGIN_QUOTE
   Does your ~Employee~ class need to define its own versions of the
   copy-control members? If so, why? If not, why not? Implement whatever
   copy-control members you think ~Employee~ needs.
   #+END_QUOTE

   there is no sensible meaning for these operation.
   #+BEGIN_SRC C++
struct Employee {
  Employee() { id_ = unique_identifier_; }
  Employee(const std::string &name): name_(name) {
    id_ = unique_identifier_;
  }
  Employee(const Employee &) = delete;
  Emplyee& operator=(const Employee &) = delete;

  int get_id() const { return id_; } 

 private:
  std::string name_;
  int id_;
  static int unique_identifier_;
};

int Employee::unique_identifier_ = 0;
   #+END_SRC

** Exercise 13.20
   #+BEGIN_QUOTE
   Explain what happens when we copy, assign, or destroy objects of our
   ~TextQuery~ and ~QueryResult~ classes from § 12.3 (p. 484).
   #+END_QUOTE

   The synthesized version will take care of the process.

** Exercise 13.21
   #+BEGIN_QUOTE
   Do you think the ~TextQuery~ and ~QueryResult~ classes need to define their
   own versions of the copy-control members? If so, why?  If not, why not?
   Implement whichever copy-control operations you think these classes require.
   #+END_QUOTE

   No. The synthesized version is okay.

* Exercises Section 13.2
** Exercise 13.22
   #+BEGIN_QUOTE
   Assume that we want ~HasPtr~ to behave like a value. That is, each object
   should have its own copy of the string to which the objects point. We’ll show
   the definitions of the copy-control members in the next section. However, you
   already know everything you need to know to implement these members. Write
   the ~HasPtr~ copy constructor and copy-assignment operator before reading on.
   #+END_QUOTE

   #+BEGIN_SRC C++
class HasPtr {
 public:
  HasPtr(const std::string &s = std::string()):
    ps(new std::string(s)), i(0) { }
  // each HasPtr has its own copy of the string to which ps points
  HasPtr(const HasPtr &p):
    ps(new std::string(*p.ps)), i(p.i) { }
  HasPtr& operator=(const HasPtr &rhs) {
    auto newp = new std::string(*rhs.ps);  // copy the underlying string
    delete ps;    // free the old memory
    ps = newp;    // copy data from rhs into this object
    i = rhs.i;
    return *this; // return this object
  }
  ~HasPtr() { delete ps; }
 private:
  std::string *ps;
  int i;
};
   #+END_SRC

* Exercises Section 13.2.1
** Exercise 13.23
   #+BEGIN_QUOTE
   Compare the copy-control members that you wrote for the solutions to the
   previous section’s exercises to the code presented here. Be sure you
   understand the differences, if any, between your code and ours.
   #+END_QUOTE

   Okay.

** Exercise 13.24
   #+BEGIN_QUOTE
   What would happen if the version of ~HasPtr~ in this section didn’t define a
   destructor? What if ~HasPtr~ didn’t define the copy constructor?
   #+END_QUOTE
   
   If ~HasPtr~ didn’t define a destructor, the memory allocated in its
   constructors will never be freed. If ~HasPtr~ didn’t define the copy
   constructor, the synthesized version will only copy the pointer, not the
   ~string~.

** Exercise 13.25
   #+BEGIN_QUOTE
   Assume we want to define a version of ~StrBlob~ that acts like a value. Also
   assume that we want to continue to use a ~shared_ptr~ so that our
   ~StrBlobPtr~ class can still use a ~weak_ptr~ to the ~vector~. Your revised
   class will need a copy constructor and copy-assignment operator but will not
   need a destructor. Explain what the copy constructor and copy-assignment
   operators must do. Explain why the class does not need a destructor.
   #+END_QUOTE

   Copy constructor and copy-assignment operator should dynamically allocate
   memory for its own , rather than share the object with the right hand
   operand.

   ~StrBlob~ uses smart pointers which can be managed with synthesized
   destructor. If an object of ~StrBlob~ is out of scope, the destructor of
   ~std::shared_ptr~ will be called automatically to free the memory dynamically
   allocated when the ~use_count~ goes to 0.

** Exercise 13.26
   #+BEGIN_QUOTE
   Write your own version of the ~StrBlob~ class described in the previous
   exercise.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <initializer_list>
#include <memory>
#include <stdexcept>

// forward declaration needed for friend declaration in StrBlob
class StrBlobPtr;

class StrBlob {
  friend class StrBlobPtr;
public:
  typedef std::vector<std::string>::size_type size_type;

  // constructors
  StrBlob();
  StrBlob(std::initializer_list<std::string> il);

  // copy constructor
  StrBlob(const StrBlob &sb);
  // copy assignment operator
  StrBlob& operator=(const StrBlob &sb);

  // size operation
  size_type size() const { return data->size(); }
  bool empty() const { return data->empty(); }

  // add and remove elements
  void push_back(const std::string &t) { data->push_back(t); }
  void pop_back();

  // element access
  std::string& front();
  std::string& back();

  // interface to StrBlobPtr
  StrBlobPtr begin();
  StrBlobPtr end();

private:
  std::shared_ptr<std::vector<std::string>> data;
  // throws msg if data[i] isn't valid
  void check(size_type i, const std::string &msg) const;
};

StrBlob::StrBlob(): data(std::make_shared<std::vector<std::string>>()) { }
StrBlob::StrBlob(std::initializer_list<std::string> il):
  data(std::make_shared<std::vector<std::string>>(il)) { };

StrBlob::StrBlob(const StrBlob &sb): data(std::make_shared<std::vector<std::string>>(*sb.data)) { }

StrBlob& StrBlob::operator=(const StrBlob &sb)
{
  data = std::make_shared<std::vector<std::string>>(*sb.data);
  return *this;
}

void StrBlob::check(size_type i, const std::string &msg) const
{
  if (i >= data->size())
    throw std::out_of_range(msg);
}

std::string& StrBlob::front()
{
  // if the vector is empty, check will throw
  check(0, "front on empty StrBlob");
  return data->front();
}

std::string& StrBlob::back()
{
  check(0, "back on empty StrBlob");
  return data->back();
}

void StrBlob::pop_back()
{
  check(0, "pop_back on empty StrBlob");
  data->pop_back();
}

// StrBlobPtr throws an exception on attempts to access a nonexistent element
class StrBlobPtr {
  friend bool eq(const StrBlobPtr &, const StrBlobPtr &);
public:
  StrBlobPtr(): curr(0) { }
  StrBlobPtr(StrBlob &a, size_t sz = 0): wptr(a.data), curr(sz) { }

  std::string& deref() const;
  StrBlobPtr& incr();		// prefix version

private:
  // check returns a shared_ptr to the vector if the check succeeds
  std::shared_ptr<std::vector<std::string>>
  check(std::size_t, const std::string &) const;

  // store a weak_ptr, which means the underlying vector might be destroyed
  std::weak_ptr<std::vector<std::string>> wptr;
  std::size_t curr;		// current position within the array
};
v
std::shared_ptr<std::vector<std::string>>
StrBlobPtr::check(std::size_t i, const std::string &msg)
const
{
  auto ret = wptr.lock();	// is the vector still around
  if (!ret)
    throw std::runtime_error("unbound StrBlobPtr");

  if (i >= ret->size())
    throw std::out_of_range(msg);

  return ret;			// otherwise, return a shared_ptr to the vector
}

std::string& StrBlobPtr::deref() const
{
  auto p = check(curr, "dereference past end");
  return (*p)[curr];		// (*p) is the vector to which this object points
}

// prefix: return a reference to the incremented object
StrBlobPtr& StrBlobPtr::incr()
{
  // if curr already points past the end of the container, can't increment it
  check(curr, "increment past end of StrBlobPtr");
  ++curr;			// advance the current state
  return *this;
}

StrBlobPtr
StrBlob::begin() { return StrBlobPtr(*this); }

StrBlobPtr
StrBlob::end() {
  auto ret = StrBlobPtr(*this, data->size());
  return ret;
}

// named equality operators for StrBlobPtr
bool eq(const StrBlobPtr &lhs, const StrBlobPtr &rhs)
{
  auto l = lhs.wptr.lock(), r = rhs.wptr.lock();
  // if the underlying vector is the same
  if (l == r)
    // then they're equal if they're both null or
    // if they point to the same element
    return (!r || lhs.curr == rhs.curr);
  else
    return false; // if they point to difference vectors, they're not equal
}

bool neq(const StrBlobPtr &lhs, const StrBlobPtr &rhs)
{
  return !eq(lhs, rhs);
}

int main()
{
  std::string ifile("data/book.txt");
  std::ifstream in(ifile);

  StrBlob b;
  std::string s;
  while (std::getline(in, s)) b.push_back(s);

  for (auto it = b.begin(); neq(it, b.end()); it.incr())
    std::cout << it.deref() << std::endl;

  return 0;
}   
   #+END_SRC

* Exercises Section 13.2.2
** Exercise 13.27
   #+BEGIN_QUOTE
   Define your own reference-counted version of ~HasPtr~.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
class HasPtr {
 public:
  // constructor allocates a new string and a new counter, which it sets to 1
  HasPtr(const std::string &s = std::string()):
    ps(new std::string(s)), i(0), use(new std::size_t(1)) { }
  // copy constructor copies all three data members and increments the counter
  HasPtr(const HasPtr &p):
    ps(p.ps), i(p.i), use(p.use) { ++*use; }
  HasPtr& operator=(const HasPtr &rhs) {
    ++*rhs.use;  // increment the use count of the right-hand operand
    if (--*use == 0) {  // then decrement this object's counter
      delete ps;        // if no other users
      delete use;       // free this object's allocated members
    }
    ps = rhs.ps;
    i = rhs.i;
    use = rhs.use; 

    return *this;
  }
  ~HasPtr() {
    if (--*use == 0) {  // if the reference count goes to 0
      delete ps;        // delete the string
      delete use;       // and the counter
    } 
  }
 private:
  std::string *ps;
  int i;
  std::size_t *use;  // member to keep track of how many objects share *ps
};   
   #+END_SRC

** Exercise 13.28
   #+BEGIN_QUOTE
   Given the following classes, implement a default constructor and the
   necessary copy-control members.
   + (a)
     #+BEGIN_SRC C++
class TreeNode {
 private:
  std::string value;
  int count;
  TreeNode *left;
  TreeNode *right;
};     
     #+END_SRC
   + (b)
     #+BEGIN_SRC C++
class BinStrTree {
 private:
  TreeNode *root;
};     
     #+END_SRC
   #+END_QUOTE
