* Exercises Section 13.1.1
** Exercise 13.1 
   #+BEGIN_QUOTE
   What is a copy constructor? When is it used?
   #+END_QUOTE

   A constructor is the *copy constructor* if its first parameter is
   a *reference* to the class type and any additional parameters have *default
   values*.

   Copy initialization ordinarily uses the copy constructor (or the move
   constructor), and it happens when we
   + Define variables using an =;
   + Pass an object as an argument to a parameter of nonreference type;
   + Return an object from a function that has a nonreference return type;
   + Brace initialize the elements in an array or the members of an aggregate
     class;
   + Some class types also use copy initialization for the objects they
     allocate.

** Exercise 13.2
   #+BEGIN_QUOTE
   Explain why the following declaration is illegal:
   #+END_QUOTE

   #+BEGIN_SRC C++
   Sales_data::Sales_data(Sales_data rhs);
   #+END_SRC

   The fact that the copy constructor is used to initialize nonreference
   parameters of class type explains why the copy constructor’s own parameter
   must be a reference. If that parameter were not a reference (like the
   declaration in this question), then the call would never succeed -- to call
   the copy constructor, we’d need to use the copy constructor to copy the
   argument, but to copy the argument, we’d need to call the copy constructor,
   and so on indefinitely.

** Exercise 13.3
   #+BEGIN_QUOTE
   What happens when we copy a ~StrBlob~? What about ~StrBlobPtr~ s?
   #+END_QUOTE
    
   The type of each member determines how that member is copied: Members of
   class type are copied by the copy constructor for that class; members of
   built-in type are copied directly. Although we cannot directly copy an array
   (§ 3.5.1, p. 114), the synthesized copy constructor copies members of array
   type by copying each element.  Elements of class type are copied by using the
   elements’ copy constructor.
 
** Exercise 13.4
   #+BEGIN_QUOTE
   Assuming ~Point~ is a class type with a public copy constructor, identify each
   use of the copy constructor in this program fragment:
   #+END_QUOTE
   #+BEGIN_SRC C++
Point global;
Point foo_bar(Point arg) // Pass an object as an argument to a parameter of nonreference type
{
  Point local = arg, *heap = new Point(global); // Define variables using an =.
  *heap = local;
  Point pa[ 4 ] = { local, *heap }; // Brace initialize the elements in an array
  return *heap; // Return an object from a function that has a nonreference return type
}   
   #+END_SRC
 
** Exercise 13.5
   #+BEGIN_QUOTE
   Given the following sketch of a class, write a copy constructor that copies
   all the members. Your constructor should dynamically allocate a new string (§
   12.1.2, p. 458) and copy the object to which ps points, rather than copying
   ps itself.
   #+END_QUOTE
   #+BEGIN_SRC C++
class HasPtr {
 public:
  HasPtr(const std::string &s = std::string()):
  ps(new std::string(s)), i(0) { }
 private:
  std::string *ps;
  int i;
};   
   #+END_SRC

   #+BEGIN_SRC C++
HasPtr::HasPtr(const HasPtr &orig): 
  ps(new std::string(*orig.ps)), i(orig.i) { }   
   #+END_SRC

* Exercises Section 13.1.2
** Exercise 13.6
   #+BEGIN_QUOTE
   What is a copy-assignment operator? When is this operator used? What does the
   synthesized copy-assignment operator do? When is it synthesized?
   #+END_QUOTE

   copy-assignment operator: Version of the assignment operator that takes an
   object of the same type as its type. Ordinarily, the copy-assignment operator
   has a parameter that is a reference to const and returns a reference to its
   object. The compiler synthesizes the copy-assignment operator if the class
   does not explicitly provide one.

** Exercise 13.7
   #+BEGIN_QUOTE
   What happens when we assign one ~StrBlob~ to another?  What about
   ~StrBlobPtrs~?
   #+END_QUOTE
    
   Just as it does for the copy constructor, the compiler generates a
   synthesized copy- assignment operator for a class if the class does not
   define its own. Analogously to the copy constructor, for some classes the
   synthesized copy-assignment operator disallows assignment (§ 13.1.6,
   p. 508). Otherwise, it assigns each nonstatic member of the right-hand object
   to the corresponding member of the left-hand object using the copy-assignment
   operator for the type of that member. Array members are assigned by assigning
   each element of the array. The synthesized copy-assignment operator returns a
   reference to its left-hand object.  As an example, the following is
   equivalent to the synthesized copy-
 
** Exercise 13.8
   #+BEGIN_QUOTE
   Write the assignment operator for the ~HasPtr~ class from exercise 13.5 in §
   13.1.1 (p. 499). As with the copy constructor, your assignment operator
   should copy the object to which ~ps~ points.
   #+END_QUOTE
 
   #+BEGIN_SRC C++
HasPtr&
HasPtr::operator=(const HasPtr &orig) {
  if(this != &orig) {
    std::string *ps_tmp = new std::string(*orig.ps);
    delete ps;
    ps = ps_tmp;
    i = orig.i;
  }
  return *this;
}   
   #+END_SRC
