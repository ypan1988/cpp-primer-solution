* Exercises Section 4.1.2
** Exercise 4.1
   #+BEGIN_QUOTE
   What is the value returned by ~5 + 10 * 20/2~?
   #+END_QUOTE

   105.

** Exercise 4.2
   #+BEGIN_QUOTE
   Using Table 4.12 (p. 166), parenthesize the following expressions
   to indicate the order in which the operands are grouped:
   + (a) ~* vec.begin()~
   + (b) ~* vec.begin() + 1~
   #+END_QUOTE

   + (a) ~*(vec.begin())~
   + (b) ~(*(vec.begin())) + 1~

* Exercises Section 4.1.3
** Exercise 4.3
   #+BEGIN_QUOTE
   Order of evaluation for most of the binary operators is left undefined to
   give the compiler opportunities for optimization. This strategy presents a
   trade-off between efficient code generation and potential pitfalls in the use
   of the language by the programmer. Do you consider that an acceptable
   trade-off? Why or why not?
   #+END_QUOTE

   Yes.

* Exercises Section 4.2
** Exercise 4.4
   #+BEGIN_QUOTE
   Parenthesize the following expression to show how it is evaluated. Test your
   answer by compiling the expression (without parentheses) and printing its
   result.
   ~12 / 3 * 4 + 5 * 15 + 24 % 4 / 2~
   #+END_QUOTE
   
   ~((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2)~
   
   result: 91

** Exercise 4.5
   #+BEGIN_QUOTE
   Determine the result of the following expressions.
   + (a) -30 * 3 + 21 / 5
   + (b) -30 + 3 * 21 / 5
   + (c) 30 / 3 * 21 % 5
   + (d) -30 / 3 * 21 % 4
   #+END_QUOTE

   + (a) -86
   + (b) -18
   + (c) 0
   + (d) -2

** Exercise 4.6
   #+BEGIN_QUOTE
   Write an expression to determine whether an ~int~ value is even or odd.
   #+END_QUOTE
   
   ival % 2 // zero means the int value is even, otherwise it is odd

** Exercise 4.7
   #+BEGIN_QUOTE
   What does overflow mean? Show three expressions that will overflow.
   #+END_QUOTE

   Overflow happens when a value is computed that is outside the range of values
   that the type can represent.
   #+BEGIN_SRC C++
short sval = 32767; ++sval;
unsigned uival = 0; --uival;
unsigned short usval = 65535; ++usval;
   #+END_SRC

* Exercises Section 4.3
** Exercise 4.8
   #+BEGIN_QUOTE
   Explain when operands are evaluated in the logical AND , logical OR , and
   equality operators.
   #+END_QUOTE

   The logical AND and OR operators always evaluate their left operand before
   the right.  Moreover, the right operand is evaluated if and only if the left
   operand does not determine the result. This strategy is known as
   short-circuit evaluation: 
   + The right side of an && is evaluated if and only if the left side is
     ~true~.
   + The right side of an || is evaluated if and only if the left side is
     ~false~.

   The operands will always be evaluated in equality operators.

** Exercise 4.9
   #+BEGIN_QUOTE
   Explain the behavior of the condition in the following ~if~:
   #+END_QUOTE
   #+BEGIN_SRC C++
const char *cp = "Hello World";
if (cp && *cp)
   #+END_SRC

   The condition is true. ~cp~ is a pointer to const char *, and it's not a
   nullptr. So the first operand is true. ~*cp~ is a const char with value 'H',
   and it is a nonzero value. So the second operad is true.

** Exercise 4.10
   #+BEGIN_QUOTE
   Write the condition for a ~while~ loop that would read ~int~s from the
   standard input and stop when the value read is equal to 42.
   #+END_QUOTE
   
   #+BEGIN_SRC C++
int ival;
while (cin >> ival && ival != 42)   
   #+END_SRC

** Exercise 4.11
   #+BEGIN_QUOTE
   Write an expression that tests four values, ~a~, ~b~, ~c~, and ~d~, and
   ensures that ~a~ is greater than ~b~, which is greater than ~c~, which is
   greater than ~d~.
   #+END_QUOTE

   #+BEGIN_SRC C++
   a > b && b > c && c > d 
   #+END_SRC

** Exercise 4.12
   #+BEGIN_QUOTE
   Assuming ~i~, ~j~, and ~k~ are all ~int~s, explain what ~i != j < k~ means.
   #+END_QUOTE

   ~i != (j < k)~

* Exercises Section 4.4
** Exercise 4.13
   #+BEGIN_QUOTE
   What are the values of i and d after each assignment?  ~int i;
   double d;~
   + (a) ~d = i = 3.5;~
   + (b) ~i = d = 3.5;~
   #+END_QUOTE

   + (a) i = 3; d = 3.0.
   + (b) d = 3.5; i = 3.0.

** Exercise 4.14
   #+BEGIN_QUOTE
   Explain what happens in each of the ~if~ tests:
   #+END_QUOTE
   #+BEGIN_SRC C++
if (42 = i)   //  ...
if (i = 42)   //  ...   
   #+END_SRC
   
   It is an error for the condition in the first ~if~ since literals are
   rvalues; The condition in second ~if~ assigns 42 to i and then tests the
   result of the assignment (The condition will be true since 42 is not zero).

** Exercise 4.15
   #+BEGIN_QUOTE
   The following assignment is illegal. Why? How would you correct it?
   #+END_QUOTE
   #+BEGIN_SRC C++
double dval; int ival; int *pi;
dval = ival = pi = 0;   
   #+END_SRC
   
   The assignment is illegal because ival and pi have different types and there
   is no conversion from the type of pi (int*) to the type of ival (int). It is
   illegal even though zero is a value that can be assigned to either object.

** Exercise 4.16
   #+BEGIN_QUOTE
   Although the following are legal, they probably do not behave as the
   programmer expects. Why? Rewrite the expressions as you think they should be.
   + (a) if (p = getPtr() != 0)
   + (b) if (i = 1024)
   #+END_QUOTE
   + (a) if ((p = getPtr()) != 0) // Because assignment has lower precedence
     than the relational operators, parentheses are usually needed around
     assignments in conditions.
   + (b) if (i == 1024) // The author of this code almost surely intended to
     test whether i is equal to 1024.

* Exercises Section 4.5
** Exercise 4.17
   #+BEGIN_QUOTE
   Explain the difference between prefix and postfix increment.
   #+END_QUOTE

   The prefix operators increments (or decrements) its operand and yields the
   changed object as its result. The postfix operators increment (or decrement)
   the operand but yield a copy of the original, unchanged value as its result.

** Exercise 4.18
   #+BEGIN_QUOTE
   What would happen if the ~while~ loop on page 148 that prints the elements
   from a ~vector~ used the prefix increment operator?
   #+END_QUOTE
   
   It will print from the second element and dereference ~v.end()~ at last,
   which is a undefined behaviour.

** Exercise 4.19
   #+BEGIN_QUOTE
   Given that ~ptr~ points to an ~int~, that ~vec~ is a ~vector<int>~, and that
   ~ival~ is an ~int~, explain the behavior of each of these expressions. Which,
   if any, are likely to be incorrect? Why? How might each be corrected?
   + (a) ~ptr != 0 && *ptr++~
   + (b) ~ival++ && ival~
   + (c) ~vec[ival++] <= vec[ival]~
   #+END_QUOTE
   (c) is incorrect. It should be ~vec[ival] <= vec[ival+1]~
