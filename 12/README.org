* Exercises Section 12.1.1
** Exercise 12.1
   #+BEGIN_QUOTE
   How many elements do ~b1~ and ~b2~ have at the end of this code?
   #+END_QUOTE
   #+BEGIN_SRC C++
StrBlob b1;
{
    StrBlob b2 = {"a", "an", "the"};
    b1 = b2;
    b2.push_back("about");
}   
   #+END_SRC

At the end of this code, ~b1~ has four elements and ~b2~ has been destroyed.

** Exercise 12.2
   #+BEGIN_QUOTE
   Write your own version of the ~StrBlob~ class including the ~const~ versions
   of ~front~ and ~back~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
#include <vector>
#include <string>
#include <initializer_list>
#include <exception>
#include <memory>

class StrBlob {
public:
  typedef std::vector<std::string>::size_type size_type;

  // constructors
  StrBlob();
  StrBlob(std::initializer_list<std::string> il);

  // size operations
  size_type size() const { return data->size(); }
  bool empty() const { return data->empty(); }

  // add and remove elements
  void push_back(const std::string &t) { data->push_back(t); }
  void pop_back();

  // element access
  std::string& front();
  std::string& back();
    
  const std::string& front() const;
  const std::string& back() const;

private:
  std::shared_ptr<std::vector<std::string>> data;
  // throws msg if data[i] isn't valid
  void check(size_type i, const std::string &msg) const;
};

// constructor
inline StrBlob::StrBlob(): data(std::make_shared<std::vector<std::string>>()) { }
inline StrBlob::StrBlob(std::initializer_list<std::string> il):
  data(std::make_shared<std::vector<std::string>>(il)) { }

std::string& StrBlob::front()
{
  // if the vector is empty, check will throw
  check(0, "front on empty StrBlob");
  return data->front();
}

const std::string& StrBlob::front() const
{
  // if the vector is empty, check will throws
  check(0, "front on empty StrBlob");
  return data->front();
}

std::string& StrBlob::back()
{
  check(0, "back on empty StrBlob");
  return data->back();
}

const std::string& StrBlob::back() const
{
  check(0, "back on empty StrBlob");
  return data->back();
}

void StrBlob::pop_back()
{
  check(0, "pop_back on empty StrBlob");
  data->pop_back();
}

void StrBlob::check(size_type i, const std::string &msg) const
{
  if (i >= data->size())
    throw std::out_of_range(msg);
}

int main()
{
  const StrBlob b1 = {"a", "an", "the"};
  StrBlob b2 = {"Hello", "World", "!"};

  std::cout << b1.front() << " " << b1.back() << std::endl;
  b2.back() = "!!!";
  std::cout << b2.front() << " " << b2.back() << std::endl;

  return 0;
}   
   #+END_SRC

** Exercise 12.3
   #+BEGIN_QUOTE
   Does this class need ~const~ versions of ~push_back~ and ~pop_back~? If so,
   add them. If not, why aren’t they needed?
   #+END_QUOTE

   No. "You can certainly do this if you want to, but there doesn't seem to be
   any logical reason. The compiler doesn't complain because this doesn't modify
   ~data~ (which is a pointer) but rather the thing ~data~ points to, which is
   perfectly legal to do with a ~const~ pointer."

** Exercise 12.4
   #+BEGIN_QUOTE
   In our ~check~ function we didn’t check whether ~i~ was greater than
   zero. Why is it okay to omit that check?
   #+END_QUOTE

   Because the type of ~i~ is ~std::vector<std::string>::size_type~ which is an
   ~unsigned~, and it will ensure ~i~ is a positive number or 0.

** Exercise 12.5
   #+BEGIN_QUOTE
   We did not make the constructor that takes an ~initializer_list~ ~explicit~
   (§ 7.5.4, p. 296). Discuss the pros and cons of this design choice.
   #+END_QUOTE
   
   If we make the constructor ~explicit~, then program will prevents automatic
   conversion from an ~initializer_list~ to ~StrBlob~ which makes it easy to
   debug but hard to use.

* Exercises Section 12.1.2
** Exercise 12.6
   #+BEGIN_QUOTE
   Write a function that returns a dynamically allocated ~vector~ of
   ~int~s. Pass that ~vector~ to another function that reads the standard input
   to give values to the elements. Pass the ~vector~ to another function to
   print the values that were read. Remember to ~delete~ the ~vector~ at the
   appropriate time.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin;
using std::cout;
using std::endl;

#include <vector>
using std::vector;

vector<int>* factory()
{
  return new vector<int>{};
}

vector<int>* read_factory(vector<int> *vec)
{
  int value;
  while (cin >> value) {
    vec->push_back(value);
  }

  return vec;
}

void print_factory(vector<int> *vec)
{
  for (auto i : *vec)
    cout << i << endl;
}

int main()
{
  vector<int>* vec = read_factory(factory());
  print_factory(vec);
  delete vec;

  return 0;
}   
   #+END_SRC

** Exercise 12.7
   #+BEGIN_QUOTE
   Redo the previous exercise, this time using ~shared_ptr~.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <iostream>
using std::cin;
using std::cout;
using std::endl;

#include <vector>
using std::vector;

#include <memory>
using std::make_shared;
using std::shared_ptr;

shared_ptr<vector<int>> factory()
{
  return make_shared<vector<int>>();
}

shared_ptr<vector<int>> read_factory(shared_ptr<vector<int>> vec)
{
  int value;
  while (cin >> value) {
    vec->push_back(value);
  }

  return vec;
}

void print_factory(shared_ptr<vector<int>> vec)
{
  for (auto i : *vec)
    cout << i << endl;
}

int main()
{
  shared_ptr<vector<int>> vec = read_factory(factory());
  print_factory(vec);

  return 0;
}   
   #+END_SRC

** Exercise 12.8
   #+BEGIN_QUOTE
   Explain what if anything is wrong with the following function.
   #+END_QUOTE
   #+BEGIN_SRC C++
bool b() {
    int* p = new int;
    // ...
    return p;
}   
   #+END_SRC

   In this question, ~p~ was the only pointer to the memory allocated. Once
   function ~b~ returns, ~p~ will be converted to a ~bool~ and the program has
   no way to free that memory. As a result, "memory leak" will occur.

}
 
** Exercise 12.9
   #+BEGIN_QUOTE
   Explain what happens in the following code:
   #+END_QUOTE
   #+BEGIN_SRC C++
int *q = new int(42), *r = new int(100);
r = q;
auto q2 = make_shared<int>(42),
r2 = make_shared<int>(100);
r2 = q2;   
   #+END_SRC

   After ~r = q;~ , both ~r~ and ~q~ will points to the same memory and the
   program has no way to free the memory to which ~r~ had pointed (result in
   memory leak).

   ~r2 = q2;~ assign ~q2~ to ~r2~, increase the use count for the object to
   which ~q2~ points, and reduce the use count of the object to which ~r2~ had
   pointed. Now the object ~r2~ had pointed to has no users, and that object is
   automatically freed.

* Exercises Section 12.1.3
** Exercise 12.10
   #+BEGIN_QUOTE
   Explain whether the following call to the ~process~ function defined on page
   464 is correct. If not, how would you correct the call?
   #+END_QUOTE
   #+BEGIN_SRC C++
shared_ptr<int> p(new int(42));
process(shared_ptr<int>(p));   
   #+END_SRC

   Correct.

** Exercise 12.11
   #+BEGIN_QUOTE
   What would happen if we called ~process~ as follows?
   #+END_QUOTE
   #+BEGIN_SRC C++
process(shared_ptr<int>(p.get()));   
   #+END_SRC

   In this call, we passed a temporary ~shared_ptr~ to ~process~. That temporary
   is destroyed when the expression in which the call appears finishes. The
   memory to which the temporary points is freed when the temporary is
   destroyed.

** Exercise 12.12
   #+BEGIN_QUOTE
   Using the declarations of ~p~ and ~sp~ explain each of the following calls to
   ~process~. If the call is legal, explain what it does. If the call is
   illegal, explain why:
   #+END_QUOTE
   #+BEGIN_SRC C++
auto p = new int();
auto sp = make_shared<int>();   
   #+END_SRC
   #+BEGIN_QUOTE
   + (a) ~process(sp);~
   + (b) ~process(new int());~
   + (c) ~process(p);~
   + (d) ~process(shared_ptr<int>(p));~
   #+END_QUOTE

   + (a) legal. copying ~sp~ increments its count; in process the reference
     count is 2.
   + (b) illegal. cannot convert ~int *~ to ~shared_ptr<int>~.
   + (c) illegal. cannot convert ~int *~ to ~shared_ptr<int>~.
   + (d) legal, but the memory will be deleted!

** Exercise 12.13
   #+BEGIN_QUOTE
   What happens if we execute the following code?
   #+END_QUOTE
   #+BEGIN_SRC C++
auto sp = make_shared<int>();
auto p = sp.get();
delete p;   
   #+END_SRC

   In this case, both ~sp~ and ~p~ point to the same memory. Destroying ~p~
   frees the memory to which ~p~ points. When ~sp~ is also destroyed, the
   pointer to that memory will be deleted a second time.

* Exercises Section 12.1.4
** Exercise 12.14
   #+BEGIN_QUOTE
   Write your own version of a function that uses a ~shared_ptr~ to manage a
   ~connection~.
   #+END_QUOTE

   #+BEGIN_SRC C++
struct destination;
struct connection;
connection connect(destination*);
void disconnect(connection);
void end_connection(connection *p) { disconnect(*p); }
void f(destination &d) {
  shared_ptr<connection> c(&d, end_connection);
  // use the connection
  // when f exits, even if by an exception, the connection will be properly closed
}   
   #+END_SRC

** Exercise 12.15
   #+BEGIN_QUOTE
   Rewrite the first exercise to use a lambda (§ 10.3.2, p.388) in place of the
   ~end_connection~ function.
   #+END_QUOTE

   #+BEGIN_SRC C++
struct destination;
struct connection;
connection connect(destination*);
void disconnect(connection);
void f(destination &d) {
  shared_ptr<connection> c(&d, [](connnection *c) { disconnect(*c); });
  // use the connection
  // when f exits, even if by an exception, the connection will be properly closed
}   
   #+END_SRC

* Exercises Section 12.1.5
** Exercise 12.16
   #+BEGIN_QUOTE
   Compilers don’t always give easy-to-understand error messages if we attempt
   to copy or assign a ~unique_ptr~. Write a program that contains these errors
   to see how your compiler diagnoses them.
   #+END_QUOTE

   #+BEGIN_SRC C++
#include <string>
using std::string;

#include <memory>
using std::unique_ptr;

int main()
{   
  unique_ptr<string> p1(new string("Stegosaurus"));
  //unique_ptr<string> p2(p1); // error: no copy for unique_ptr
  unique_ptr<string> p3;
  //p3 = p2; // error: no assign for unique_ptr
 
  return 0;
}   
   #+END_SRC

** Exercise 12.17
   #+BEGIN_QUOTE
   Which of the following unique_ptr declarations are illegal or likely to
   result in subsequent program error? Explain what the problem is with each
   one.
   #+END_QUOTE
   #+BEGIN_SRC C++
int ix = 1024, *pi = &ix, *pi2 = new int(2048);
typedef unique_ptr<int> IntP;   
   #+END_SRC
   #+BEGIN_QUOTE
   + (a) IntP p0(ix);
   + (b) IntP p1(pi);
   + (c) IntP p2(pi2);
   + (d) IntP p3(&ix); 
   + (e) IntP p4(new int(2048));
   + (f) IntP p5(p2.get());
   #+END_QUOTE
 
** Exercise 12.18 
   #+BEGIN_QUOTE
   Why doesn’t shared_ptr have a release member?
   #+END_QUOTE
